

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API reference &mdash; Python NCS tools 0.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Python NCS tools 0.2 documentation" href="../index.html" />
    <link rel="prev" title="Reservoir" href="../examples/reservoir.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../examples/reservoir.html" title="Reservoir"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Python NCS tools 0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="api-reference">
<h1>API reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<p>This page is autogenerated and contains the docstrings of the python packages used in the <a class="reference external" href="http://ncs.ethz.ch">NCS</a> group</p>
<div class="section" id="pyncs">
<h2>pyNCS<a class="headerlink" href="#pyncs" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyNCS.Chip">
<em class="property">class </em><tt class="descclassname">pyNCS.</tt><tt class="descname">Chip</tt><big>(</big><em>CSVfile</em>, <em>id='noname'</em>, <em>amdaid='01'</em>, <em>host='localhost'</em>, <em>amdaClient=None</em>, <em>debug=False</em><big>)</big><a class="headerlink" href="#pyNCS.Chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Class emulating a chip
-Sadique Sheik,Emre Neftci
- April 2009</p>
<p>-extended by <a class="reference external" href="mailto:andstein&#37;&#52;&#48;student&#46;ethz&#46;ch">andstein<span>&#64;</span>student<span>&#46;</span>ethz<span>&#46;</span>ch</a> on February 2010
Chip(CSVfile,id=&#8217;noname&#8217;,amdaid=1)</p>
<p>The CSV file should be in the tab separated csv format</p>
<dl class="method">
<dt id="pyNCS.Chip.disableDAC">
<tt class="descname">disableDAC</tt><big>(</big><em>biasName</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.disableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>disableDAC(&#8216;biasName&#8217;)sets the DAC to tristate</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.enableDAC">
<tt class="descname">enableDAC</tt><big>(</big><em>biasName</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.enableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>enableDAC(&#8216;biasName&#8217;)restores the DAC value in the ram if it was disabled</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.getBias">
<tt class="descname">getBias</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.getBias" title="Permalink to this definition">¶</a></dt>
<dd><p>getBias(biasName) Returns the bias value of &#8220;biasName&#8221;
getBias(biaslist) Returns a dict with biasname and value pairs
getBias(biasName1,biasName2) Returns a dict with biasname and value pairs
getBias() Returns a dict of all {biasName:value,..} pairs</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.getBiasNames">
<tt class="descname">getBiasNames</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Chip.getBiasNames" title="Permalink to this definition">¶</a></dt>
<dd><p>getBiasNames() returns a list of all the biases</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.getChipName">
<tt class="descname">getChipName</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Chip.getChipName" title="Permalink to this definition">¶</a></dt>
<dd><p>return the attribute &#8216;id&#8217; of this Chip object</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.grepbias">
<tt class="descname">grepbias</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.grepbias" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all biases and values containing the given string.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.gui">
<tt class="descname">gui</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Chip.gui" title="Permalink to this definition">¶</a></dt>
<dd><p>gui() pops up the GUI for the chip in a different thread</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.interpret">
<tt class="descname">interpret</tt><big>(</big><em>reply</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.interpret" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal function-Not intended for users. It tries to make sense of the strings returned by the server in the context of the Chip</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.loadBiases">
<tt class="descname">loadBiases</tt><big>(</big><em>CSVfile) loads the bias valuess from the CSV file created with saveBiases(CSVfile</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.loadBiases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.restart">
<tt class="descname">restart</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Chip.restart" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.saveBiases">
<tt class="descname">saveBiases</tt><big>(</big><em>filename</em>, <em>block=None</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.saveBiases" title="Permalink to this definition">¶</a></dt>
<dd><p>saveBiases(fileName) saves all the biases of the chip to a file</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.setBias">
<tt class="descname">setBias</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.setBias" title="Permalink to this definition">¶</a></dt>
<dd><p>setBias(biasName, biasValue) sets the value of &#8220;biasName&#8221; to &#8220;biasValue&#8221;</p>
<dl class="docutils">
<dt>setBias({&#8216;biasName&#8217;:value, ...}) can be used to set more than one bias at a time. Input should be a dict object</dt>
<dd>Optionally you can use debug=True/False for debugging</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.setscannext">
<tt class="descname">setscannext</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Chip.setscannext" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts the scanner position by one</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.setscanx">
<tt class="descname">setscanx</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.setscanx" title="Permalink to this definition">¶</a></dt>
<dd><p>setscanx(x) sets the scanner position to x</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.setscanxy">
<tt class="descname">setscanxy</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.setscanxy" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the scan position on a 2D chip</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Chip.switchoff">
<tt class="descname">switchoff</tt><big>(</big><em>biasName</em><big>)</big><a class="headerlink" href="#pyNCS.Chip.switchoff" title="Permalink to this definition">¶</a></dt>
<dd><p>switchoff(&#8216;biasName&#8217;) switches off the bias</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.Bias">
<em class="property">class </em><tt class="descclassname">pyNCS.</tt><tt class="descname">Bias</tt><big>(</big><em>r</em>, <em>amdaboard</em>, <em>norm</em><big>)</big><a class="headerlink" href="#pyNCS.Bias" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Class emulating a bias</dt>
<dd><p class="first">-Sadique Sheik, Emre Neftci
April 2009</p>
<p class="last">Bias(chip,properties) where properties is a dict object with the below keys</p>
</dd>
</dl>
<p>[&#8216;<a href="#id1"><span class="problematic" id="id2">*</span></a>channel&#8217;,&#8217;block&#8217;,&#8217;<a href="#id3"><span class="problematic" id="id4">*</span></a>signal&#8217;,&#8217;<a href="#id5"><span class="problematic" id="id6">*</span></a>bias&#8217;,&#8217;range&#8217;,&#8217;description&#8217;,&#8217;fet&#8217;,&#8217;pad&#8217;]</p>
<dl class="method">
<dt id="pyNCS.Bias.disableDAC">
<tt class="descname">disableDAC</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Bias.disableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>disableDAC() disables the bias if it is a DAC</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Bias.enableDAC">
<tt class="descname">enableDAC</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Bias.enableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>enableDAC() enables the bias if it is a DAC</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Bias.getValue">
<tt class="descname">getValue</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Bias.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>getValue() returns bias value</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Bias.setValue">
<tt class="descname">setValue</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyNCS.Bias.setValue" title="Permalink to this definition">¶</a></dt>
<dd><p>setValue(value) sets the bias value</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Bias.switchoff">
<tt class="descname">switchoff</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Bias.switchoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch off the bias</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.Bias.v">
<tt class="descname">v</tt><a class="headerlink" href="#pyNCS.Bias.v" title="Permalink to this definition">¶</a></dt>
<dd><p>Bias value</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.Bias.value">
<tt class="descname">value</tt><a class="headerlink" href="#pyNCS.Bias.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Bias value</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.Setup">
<em class="property">class </em><tt class="descclassname">pyNCS.</tt><tt class="descname">Setup</tt><big>(</big><em>filename=''</em><big>)</big><a class="headerlink" href="#pyNCS.Setup" title="Permalink to this definition">¶</a></dt>
<dd><p>contains all informations conerning a given multichip aVLSI setup:</p>
<ul class="simple">
<li>a list of <tt class="docutils literal"><span class="pre">pyNCS.Chip</span></tt>, containing each :<ul>
<li>an id identifying this particular instance</li>
<li>its AMDA id</li>
<li>input &amp; output channels</li>
<li>a chipfile containing naming scheme, chip class name etc</li>
</ul>
</li>
<li>for &#8216;setting up a setup&#8217;<ol class="arabic">
<li>initialize</li>
<li>create <a href="#id7"><span class="problematic" id="id8">``</span></a>pyNCS.Chip``s with channel information</li>
<li><tt class="docutils literal"><span class="pre">.add()</span></tt> them</li>
<li><tt class="docutils literal"><span class="pre">.update()</span></tt> the channels</li>
<li><tt class="docutils literal"><span class="pre">.apply()</span></tt> the channels if you want to use this setup as default</li>
</ol>
</li>
<li>capabilities for loading/storing theses informations<ul>
<li><tt class="docutils literal"><span class="pre">load()</span></tt> and <tt class="docutils literal"><span class="pre">save()</span></tt> to save the setting into an <tt class="docutils literal"><span class="pre">.XML</span></tt> file</li>
</ul>
</li>
<li>convinience methods&amp;variables such as<ul>
<li>translate channel,id &lt;-&gt; chip object</li>
<li><tt class="docutils literal"><span class="pre">.seq</span></tt>, <tt class="docutils literal"><span class="pre">.mon</span></tt> : the sequencer/monitor created for this setup</li>
</ul>
</li>
<li>&#8216;dummy&#8217;-chip<ul>
<li>empty channels must be specified nevertheless; that&#8217;s what the dummy
chip is for</li>
<li>you e.g. can use that empty channel for stimulating</li>
</ul>
</li>
</ul>
<dl class="method">
<dt id="pyNCS.Setup.ShowMappingGui">
<tt class="descname">ShowMappingGui</tt><big>(</big><em>update=True</em><big>)</big><a class="headerlink" href="#pyNCS.Setup.ShowMappingGui" title="Permalink to this definition">¶</a></dt>
<dd><p>Show MappingGui of the current mapping table.
If update is True it first reads the mapping table from map host.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Setup.add">
<tt class="descname">add</tt><big>(</big><em>chip</em>, <em>chipid</em><big>)</big><a class="headerlink" href="#pyNCS.Setup.add" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a chip-instance to this setup</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Setup.aerDummy">
<tt class="descname">aerDummy</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Setup.aerDummy" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a placeholder pyST.addrSpec</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Setup.apply">
<tt class="descname">apply</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Setup.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>sets default monitor/sequencer to this setup</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Setup.at">
<tt class="descname">at</tt><big>(</big><em>channel</em>, <em>inout</em><big>)</big><a class="headerlink" href="#pyNCS.Setup.at" title="Permalink to this definition">¶</a></dt>
<dd><p>finds a chip by channel</p>
<p>channel : where the chip is connected to</p>
<p>inout : either &#8216;in&#8217; or &#8216;out&#8217; &#8211; from the chip&#8217;s point o view</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Setup.dumpXML">
<tt class="descname">dumpXML</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.Setup.dumpXML" title="Permalink to this definition">¶</a></dt>
<dd><p>for backwards compatibility only</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Setup.find">
<tt class="descname">find</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#pyNCS.Setup.find" title="Permalink to this definition">¶</a></dt>
<dd><p>finds a chip by id</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Setup.load">
<tt class="descname">load</tt><big>(</big><em>filename</em>, <em>prefix=''</em>, <em>offline=False</em><big>)</big><a class="headerlink" href="#pyNCS.Setup.load" title="Permalink to this definition">¶</a></dt>
<dd><p>parses an XML file created by .dumpXML()
<em>filename</em> setup file name
<em>prefix</em> path to be prepended to chipfile names
<em>offline</em> if True, the chips will not be configured (&#8220;pretend&#8221; mode).</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Setup.load_setuptype">
<tt class="descname">load_setuptype</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.Setup.load_setuptype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.Setup.parseXML">
<tt class="descname">parseXML</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.Setup.parseXML" title="Permalink to this definition">¶</a></dt>
<dd><p>for backwards compatibility only</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Setup.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Setup.update" title="Permalink to this definition">¶</a></dt>
<dd><p>updates the default monitor/sequencer (pyST) with the chips contained
in this setup &#8211; always call this function when finished with adding chips</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.AddrGroup">
<em class="property">class </em><tt class="descclassname">pyNCS.</tt><tt class="descname">AddrGroup</tt><big>(</big><em>name</em>, <em>description=None</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>A AddrGroup is a group of chip addresses. They can be of grouptype &#8216;in&#8217; or of grouptype &#8216;out&#8217;. A description
is needed for populating the group.
AddrGroup lives in the setup, which means one can address neurons without caring about on which
chip.</p>
<dl class="docutils">
<dt>Ex.:</dt>
<dd><p class="first">setup = pyNCS.Setup(&#8216;setuptype.xml&#8217;)
setup.load(&#8216;setup&#8217;)
setup.apply()</p>
<p># output from the retina
group1 = AddrGroup(&#8216;retina output&#8217;)
group1.populate_rectangle(</p>
<blockquote>
<div>setup, &#8216;retina&#8217;, &#8216;out&#8217;, [0,0,0], [64,64,0], n = 28*28 )</div></blockquote>
<p># input from the retina
group2 = AddrGroup(&#8216;A1 cortex learning input&#8217;)
group2.populate_rectangle(setup, &#8216;ifslwta_0&#8217;, &#8216;in&#8217;, [0,4], [28,32])</p>
<p># input from the sequencer
group3 = AddrGroup(&#8216;A1 cortex excitatory input&#8217;)
group3.populate_rectangle(setup, &#8216;ifslwta_0&#8217;, &#8216;in&#8217;, [0,2], [28,2])</p>
<p># input from the sequencer
group4 = AddrGroup(&#8216;A1 cortex excitatory inhibitory&#8217;)
group4.populate_rectangle(setup, &#8216;ifslwta_0&#8217;, &#8216;in&#8217;, [0,2], [28,2])</p>
<p>group5 = AddrGroup(&#8216;56 trains from sequencer&#8217;)
group4.populate_by_number(setup, &#8216;seq&#8217;, &#8216;out&#8217;, 56)</p>
<p># you want to treat group3 and group4 as a whole
group4.join_with(group3)</p>
<p>mapping = []
mapping = group1.connect_one2one(group2)</p>
<blockquote>
<div># the connect functions will maybe go in some Mapping module</div></blockquote>
<p># ... and so on and so forth ...</p>
<p class="last">setMappings(mapping)</p>
</dd>
</dl>
<dl class="method">
<dt id="pyNCS.AddrGroup.add">
<tt class="descname">add</tt><big>(</big><em>setup</em>, <em>addresses</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of addresses to a group.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.AddrGroup.ch_addr">
<tt class="descname">ch_addr</tt><a class="headerlink" href="#pyNCS.AddrGroup.ch_addr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.getLaddr">
<tt class="descname">getLaddr</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.getLaddr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.getPaddr">
<tt class="descname">getPaddr</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.getPaddr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.is_empty">
<tt class="descname">is_empty</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.is_empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyNCS.AddrGroup.laddr">
<tt class="descname">laddr</tt><a class="headerlink" href="#pyNCS.AddrGroup.laddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical addresses</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.AddrGroup.paddr">
<tt class="descname">paddr</tt><a class="headerlink" href="#pyNCS.AddrGroup.paddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Physical addresses</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.populate_by_number">
<tt class="descname">populate_by_number</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>grouptype</em>, <em>n</em>, <em>dims</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.populate_by_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate with the given number of neuron, doesn&#8217;t matter the shape.
Needs the number of dimensions
WARNING: This should go in upper layer of abstraction.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.populate_circle">
<tt class="descname">populate_circle</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.populate_circle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.populate_line">
<tt class="descname">populate_line</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>grouptype</em>, <em>addresses</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.populate_line" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.populate_rectangle">
<tt class="descname">populate_rectangle</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>grouptype</em>, <em>p1</em>, <em>p2</em>, <em>z=None</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.populate_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate with all the neurons within the rectangle&#8217;s given cohordinates. If n is given,
populate with the given number of neurons instead of all neurons in the rectangle.
z defines the 3d cohordinate, e.g. retina polarity or synapse in the 2d chip.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.populate_rectangle_coarse">
<tt class="descname">populate_rectangle_coarse</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.populate_rectangle_coarse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.remove">
<tt class="descname">remove</tt><big>(</big><em>address</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove list of addresses to a group.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.repopulate">
<tt class="descname">repopulate</tt><big>(</big><em>setup</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.repopulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Repopulates laddr and paddr with respect to addr</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.setLaddr">
<tt class="descname">setLaddr</tt><big>(</big><em>ad</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.setLaddr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.setPaddr">
<tt class="descname">setPaddr</tt><big>(</big><em>ad</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.setPaddr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.sort">
<tt class="descname">sort</tt><big>(</big><em>order=None</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort all the addresses with the given order. If the order is None it
orders by the last column of the address (most probably the column of
synapses).</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.spiketrains">
<tt class="descname">spiketrains</tt><big>(</big><em>spikes=</em><span class="optional">[</span><span class="optional">]</span>, <em>t_start=0</em>, <em>t_stop=None</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.spiketrains" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a stimulus with the desired SpikeList.
spikes : list of tuples (id, time)
All the arguments are the same as that of a pyST.SpikeList</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.spiketrains_1D_bump">
<tt class="descname">spiketrains_1D_bump</tt><big>(</big><em>pos</em>, <em>width</em>, <em>ampl</em>, <em>t_start=0.0</em>, <em>duration=1000.0</em>, <em>channel=None</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.spiketrains_1D_bump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.spiketrains_inh_generator">
<tt class="descname">spiketrains_inh_generator</tt><big>(</big><em>rate</em>, <em>t</em>, <em>channel=None</em>, <em>base_generator=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.spiketrains_inh_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create inhomogeneous spiketrains.
The process is defined by the base_generator function. See pyST.STCreate for available functions.
Rate is a vector of rates.
The first dimension of rates corresponds to the neurons
The second dimension corresponds to the time bin. The length of this must be the same as t.
In addition, the rates <em>must</em> end with 0 to mark the end of the last bin.
keyword arguments kwargs are passed to the spiketrain generator.
See also pyST.STCreate.inh_poisson_generator
Kewword arguments are passed to the spike generator. Default is regular.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.spiketrains_inh_poisson">
<tt class="descname">spiketrains_inh_poisson</tt><big>(</big><em>rate</em>, <em>t</em>, <em>channel=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.spiketrains_inh_poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>Create inhomogeneous poisson spiketrains. Rate is a vector of rates.
The first dimension of rates corresponds to the neurons
The second dimension corresponds to the time bin. The length of this must be the same as t.
In addition, the rates <em>must</em> end with 0 to mark the end of the last bin.
keyword arguments kwargs are passed to the spiketrain generator.
See also pyST.STCreate.inh_poisson_generator</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.spiketrains_poisson">
<tt class="descname">spiketrains_poisson</tt><big>(</big><em>rate</em>, <em>t_start=0.0</em>, <em>duration=1000.0</em>, <em>channel=None</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.spiketrains_poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a poisson spiketrain for each address on the group.
You can use channel argument to enforce a particular channel.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.spiketrains_regular">
<tt class="descname">spiketrains_regular</tt><big>(</big><em>rate</em>, <em>offset=0.0</em>, <em>t_start=0.0</em>, <em>duration=1000.0</em>, <em>jitter=False</em>, <em>channel=None</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.spiketrains_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular spiketrain for each address on the group.
You can use channel argument to enforce a particular channel.
Use an offset vector to add an offset shift to the trains (must be a
vector).</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd>rate    - the rate of the discharge (in Hz). Can be an iterable
t_start - the beginning of the SpikeTrain (in ms)
offet   - Offset the spiketrain by this number (in ms.). Can be an iterable.
jitter  - whether the spiketrain should be jittered by an amount numpy.random.rand()/rate
duration- The duration of the SpikeTrain (in ms)
channel - Channel argument to enforce a particular channel</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.spiketrains_regular_gaussian">
<tt class="descname">spiketrains_regular_gaussian</tt><big>(</big><em>rate</em>, <em>offset=0.0</em>, <em>scale=5.0</em>, <em>t_start=0.0</em>, <em>duration=1000.0</em>, <em>channel=None</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.spiketrains_regular_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SpikeTrain whose spikes are regularly spaced, but jittered
according to a Gaussian distribution around the spiking period, with
the given rate (Hz) and stopping time t_stop (milliseconds).</p>
<p>Note: t_start is always 0.0, thus all realizations are as if they
spiked at t=0.0, though this spike is not included in the SpikeList.</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd><p class="first">rate    - the rate of the discharge (in Hz). Can be an iterable
t_start - the beginning of the SpikeTrain (in ms)
phase   - Use an offset vector to add an offset shift to the spike trains. Can be an iterable
scale   - width of the Gaussian distribution placed at the regular</p>
<blockquote>
<div>spike times, according to which the spike will be drawn (in ms)</div></blockquote>
<p class="last">duration- The duration of the SpikeTrain (in ms)
channel - Channel argument to enforce a particular channel</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyNCS.AddrGroup.spiketrains_single">
<tt class="descname">spiketrains_single</tt><big>(</big><em>spike_time</em>, <em>t_after=100</em><big>)</big><a class="headerlink" href="#pyNCS.AddrGroup.spiketrains_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a spiketrain with a single event with the given spike_time for all the addresses in the group.
Inputs:
<em>spike_time</em>: a float or a vector of floats indicating the spike times. If a vector is given, each entry is used once for each address in the logical addresses of the group (in the same order as self.laddr)
<em>t_after</em> ms after the spike</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.Block">
<em class="property">class </em><tt class="descclassname">pyNCS.</tt><tt class="descname">Block</tt><big>(</big><em>neurochip</em><big>)</big><a class="headerlink" href="#pyNCS.Block" title="Permalink to this definition">¶</a></dt>
<dd><p>A group of items which share some common properties. Can represent soma or synapses.
Direct initialization not intended. Should be obtained from the setup or chip NeuronChip object.</p>
</dd></dl>

<dl class="class">
<dt id="pyNCS.NeuroSetup">
<em class="property">class </em><tt class="descclassname">pyNCS.</tt><tt class="descname">NeuroSetup</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.NeuroSetup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyNCS.NeuroSetup.stimulate">
<tt class="descname">stimulate</tt><big>(</big><em>stim</em>, <em>client_kwargs={}</em>, <em>com_kwargs={}</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.NeuroSetup.stimulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a pyAex.netClient, stimulate, filter with monitors, stop the client.
Keyword arguments are those of pyAex.client.stimulate()</p>
<p>Returns raw output</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.Population">
<em class="property">class </em><tt class="descclassname">pyNCS.</tt><tt class="descname">Population</tt><big>(</big><em>name</em>, <em>description</em>, <em>setup=None</em>, <em>chipid=None</em>, <em>neurontype=None</em><big>)</big><a class="headerlink" href="#pyNCS.Population" title="Permalink to this definition">¶</a></dt>
<dd><p>Population is a set of neurons and corresponding synapses. Population can have parameters
(efficacy of excitatory input synapses, ...).
This is on top of synapses and is intended to be used by the user to create neural networks.</p>
<dl class="method">
<dt id="pyNCS.Population.add">
<tt class="descname">add</tt><big>(</big><em>addresses</em><big>)</big><a class="headerlink" href="#pyNCS.Population.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a neuron (with all its synapses) to the population. Population has to
be populated already. Address has to be of the appropriate format for
the chip on which the population has been allocated.
Arguments are:</p>
<blockquote>
<div><ul class="simple">
<li>addresses: neuron address in human format (e.g. [10, 2] for neuron
[10,2] in a 2D chip.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Population.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Population.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the population back to its original state.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Population.init">
<tt class="descname">init</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>neurontype</em><big>)</big><a class="headerlink" href="#pyNCS.Population.init" title="Permalink to this definition">¶</a></dt>
<dd><p>self.init ==&gt; self.__populate_init__</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Population.isinit">
<tt class="descname">isinit</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Population.isinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if population is initiated with setup, chipid and
neurontype, e.g. not populated.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.Population.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyNCS.Population.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.Population.populate_all">
<tt class="descname">populate_all</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>neurontype</em><big>)</big><a class="headerlink" href="#pyNCS.Population.populate_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate all the neurons in the given chip.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Population.populate_by_id">
<tt class="descname">populate_by_id</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>neurontype</em>, <em>id_list</em>, <em>axes=0</em><big>)</big><a class="headerlink" href="#pyNCS.Population.populate_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the given addresses (as list) from the neuronblock available
addresses. It takes the first n addresses if offset is not set.
Arguments are:</p>
<blockquote>
<div><ul class="simple">
<li>setup: a NeuroSetup</li>
<li>chipid: id of the chip as expressed in setup.xml</li>
<li>neurontype: id of neurons as expressed in chipfile.xml (e.g.</li>
</ul>
<p>&#8216;excitatory&#8217;)
- id_list: the list of ids for neurons to allocate (human addresses)
- axes: chosse the axes by which to filter the addresses</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Population.populate_by_number">
<tt class="descname">populate_by_number</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>neurontype</em>, <em>n</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#pyNCS.Population.populate_by_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the given number of addresses from the neuronblock available
addresses. It takes the first n addresses if offset is not set. Arguments
are:</p>
<blockquote>
<div><ul class="simple">
<li>setup: a NeuroSetup</li>
<li>chipid: id of the chip as expressed in setup.xml</li>
<li>neurontype: id of neurons as expressed in chipfile.xml (e.g.</li>
</ul>
<p>&#8216;excitatory&#8217;)
- n: the number of neuron to allocate
- offset: imposes not to take the first addresses</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Population.populate_by_topology">
<tt class="descname">populate_by_topology</tt><big>(</big><em>setup, chipid, neurontype, topology='rectangle', topology_kwargs={'p2': [63, 0], 'p1': [0, 0]}</em><big>)</big><a class="headerlink" href="#pyNCS.Population.populate_by_topology" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the given number of addresses by respecting the chips natural topology (i.e. 0 to n%X+n/Y). It takes the first n addresses if offset is not set. Arguments
are:</p>
<blockquote>
<div><ul class="simple">
<li>setup: a NeuroSetup</li>
<li>neurontype: id of neurons as expressed in chipfile.xml (e.g.</li>
</ul>
<p>&#8216;excitatory&#8217;)
- n: the number of neuron to allocate</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Population.populate_sparse">
<tt class="descname">populate_sparse</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>neurontype</em>, <em>p=0.3</em><big>)</big><a class="headerlink" href="#pyNCS.Population.populate_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate picking random addresses from the neuronblock of all possible
addresses with probability p. Arguments are:</p>
<blockquote>
<div><ul class="simple">
<li>setup: a NeuroSetup</li>
<li>chipid: id of the chip as expressed in setup.xml</li>
<li>neurontype: id of neurons as expressed in chipfile.xml (e.g.</li>
</ul>
<p>&#8216;excitatory&#8217;)
- p: probability of picking neurons in [0, 1)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Population.remove">
<tt class="descname">remove</tt><big>(</big><em>address</em><big>)</big><a class="headerlink" href="#pyNCS.Population.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a neuron (with all its synapses) from the population.
Arguments are:</p>
<blockquote>
<div><ul class="simple">
<li>address: neuron address in human format (e.g. [10, 2] for neuron
[10,2] in a 2D chip.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Population.union">
<tt class="descname">union</tt><big>(</big><em>population</em><big>)</big><a class="headerlink" href="#pyNCS.Population.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given population&#8217;s addresses to the existing one. If the
address is already there, it doesn&#8217;t add.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.Connection">
<em class="property">class </em><tt class="descclassname">pyNCS.</tt><tt class="descname">Connection</tt><big>(</big><em>popsrc</em>, <em>popdst</em>, <em>synapse</em>, <em>fashion='one2one'</em>, <em>fashion_kwargs={}</em>, <em>append=True</em>, <em>setup=None</em><big>)</big><a class="headerlink" href="#pyNCS.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>A class representing the connections between populations.</p>
</dd></dl>

<dl class="class">
<dt id="pyNCS.Mapping">
<em class="property">class </em><tt class="descclassname">pyNCS.</tt><tt class="descname">Mapping</tt><big>(</big><em>name</em>, <em>description=None</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>A class representing the mapping between groups of chip addresses.</p>
<dl class="method">
<dt id="pyNCS.Mapping.add_edge">
<tt class="descname">add_edge</tt><big>(</big><em>groupsrc</em>, <em>groupdst</em>, <em>arrowhead='normal'</em>, <em>dir='forward'</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping.add_edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Mapping.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear mapping list.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.connect">
<tt class="descname">connect</tt><big>(</big><em>groupsrc</em>, <em>groupdst</em>, <em>expand=True</em>, <em>fashion='one2one'</em>, <em>fashion_kwargs={}</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap the connect call to all type of different connectivity functions.
Arguments to specific fashion can be passed through keyword arguments.
Default fashion is &#8216;one2one&#8217;. When check is True synapses cannot be
output addresses and somas cannot be input addresses.
Example:</p>
<blockquote>
<div>mymapping.connect(src, dst, &#8220;all2all&#8221;, {&#8216;expand&#8217;:False}</div></blockquote>
<dl class="docutils">
<dt>which is equivalent to:</dt>
<dd>mymapping.__connect_all2all__(src, dst, expand=False}</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.import_from_connections">
<tt class="descname">import_from_connections</tt><big>(</big><em>connections_list</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping.import_from_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the list of connections and updates its mapping table.
Connections must be pyNCS.Connection instancies.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.is_connect_possible">
<tt class="descname">is_connect_possible</tt><big>(</big><em>groupsrc</em>, <em>groupdst</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping.is_connect_possible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.load">
<tt class="descname">load</tt><big>(</big><em>filename</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the mapping from a file.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.map_events">
<tt class="descname">map_events</tt><big>(</big><em>events</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping.map_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Map events in software.
Input:
<em>paddr</em>: a pyST.events object, containing physical addresses
Output:
evetns with mapped Physical addresses</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.mapping_dict">
<tt class="descname">mapping_dict</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Mapping.mapping_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of the mappings</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.merge">
<tt class="descname">merge</tt><big>(</big><em>pyncs_mapping</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the existing mapping with a given one. It acts on two
pyNCS.Mapping instancies.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.prepare">
<tt class="descname">prepare</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Mapping.prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Run any functions before applying the mapping table</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the mapping into a file.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.save_graph">
<tt class="descname">save_graph</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping.save_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.Mapping.write">
<tt class="descname">write</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.Mapping.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.SpikeMonitor">
<em class="property">class </em><tt class="descclassname">pyNCS.</tt><tt class="descname">SpikeMonitor</tt><big>(</big><em>addr_group</em>, <em>plot_args=None</em><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for monitoring spiking activity during experimentation.
API is the one of AddrGroup.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pop_mon</span> <span class="o">=</span> <span class="n">SpikeMonitor</span><span class="p">(</span><span class="n">pop</span><span class="o">.</span><span class="n">soma</span><span class="p">,</span> <span class="n">plot_args</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;color&#39;</span><span class="p">:</span><span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="s">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsetup</span><span class="o">.</span><span class="n">monitors</span><span class="o">.</span><span class="n">import_monitors</span><span class="p">([</span><span class="n">pop_mon</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsetup</span><span class="o">.</span><span class="n">stimulate</span><span class="p">(</span><span class="n">stStim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsetup</span><span class="o">.</span><span class="n">monitors</span><span class="o">.</span><span class="n">raster_plot</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyNCS.SpikeMonitor.composite_plot">
<tt class="descname">composite_plot</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.composite_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Composite plot of the spikelist. plot_kwargs is passed to the plot in raster_plot, whereas kwargs and args are passed to raster_plot.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.SpikeMonitor.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the SpikeMonitor</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.SpikeMonitor.firing_rates">
<tt class="descname">firing_rates</tt><big>(</big><em>time_bin=30</em>, <em>mean=True</em>, <em>offset=None</em><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.firing_rates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.SpikeMonitor.get_normalized_addr">
<tt class="descname">get_normalized_addr</tt><big>(</big><em>s_start=0.0</em>, <em>s_stop=1.0</em><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.get_normalized_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a an address list with the spikelist addresses mapped linearly to the interval (s_start, s_stop)</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.SpikeMonitor.get_remapped_spikelist">
<tt class="descname">get_remapped_spikelist</tt><big>(</big><em>s_start=0.0</em>, <em>s_stop=1.0</em><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.get_remapped_spikelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a spikelist whose addresses are mapped linearly to the interval (s_start, s_stop)</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.SpikeMonitor.get_short_name">
<tt class="descname">get_short_name</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.get_short_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get first word of self.name, used for labels in raster plot.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.SpikeMonitor.mean_rate">
<tt class="descname">mean_rate</tt><big>(</big><em>t_start=None</em>, <em>t_stop=None</em><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.mean_rate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.SpikeMonitor.populate">
<tt class="descname">populate</tt><big>(</big><em>st</em><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.populate" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate SpikeMonitor with monitered events</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.SpikeMonitor.raster_plot">
<tt class="descname">raster_plot</tt><big>(</big><em>plot_kwargs={}</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.raster_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Raster plot of the spikelist. plot_kwargs is passed to the plot in raster_plot, whereas kwargs and args are passed to raster_plot.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.SpikeMonitor.set_plotargs">
<tt class="descname">set_plotargs</tt><big>(</big><em>kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.set_plotargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes plot arguments according to SpikeMonitor&#8217;s default, but does not overwrite user-defined keyword arguments</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.SpikeMonitor.sl">
<tt class="descname">sl</tt><a class="headerlink" href="#pyNCS.SpikeMonitor.sl" title="Permalink to this definition">¶</a></dt>
<dd><p>SpikeList of the monitor. The SpikeList is constructed Just in Time.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.SpikeMonitor.toSpikeListMonitor">
<tt class="descname">toSpikeListMonitor</tt><big>(</big><em>st</em><big>)</big><a class="headerlink" href="#pyNCS.SpikeMonitor.toSpikeListMonitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform SpikeList <em>st</em> into a SpikeTrainMonitor object</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyAMDA.AMDA">
<span id="pyamda"></span><h2>pyAMDA<a class="headerlink" href="#module-pyAMDA.AMDA" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyAMDA.AMDA.AmdaBoard">
<em class="property">class </em><tt class="descclassname">pyAMDA.AMDA.</tt><tt class="descname">AmdaBoard</tt><big>(</big><em>board</em>, <em>host='localhost'</em>, <em>amdaClient=None</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard" title="Permalink to this definition">¶</a></dt>
<dd><p>Class emulating an AmdaBoard</p>
<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.cmd">
<tt class="descname">cmd</tt><big>(</big><em>command</em>, <em>wait=False</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>cmdamda(board,command)</p>
<dl class="docutils">
<dt>sends the &#8216;command&#8217; string to the device and returns the output back.</dt>
<dd>the &#8216;board&#8217; can either be the path to the device, or just the device ID.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.commit">
<tt class="descname">commit</tt><big>(</big><em>board</em>, <em>typ</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;board&#8217; can be the amda ID or device path,</p>
<p>&#8216;typ&#8217; is either &#8216;dac&#8217; or &#8216;BG&#8217;</p>
<p>Applies all the values on the ram to the respective channels</p>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.disableDAC">
<tt class="descname">disableDAC</tt><big>(</big><em>channel</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.disableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>disableDAC(board,channel),</p>
<p>&#8216;board&#8217; can be the amda ID or device path,</p>
<p>&#8216;channel&#8217; is the channel number,</p>
<blockquote>
<div>sets the DAC to a tristate mode</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.enableDAC">
<tt class="descname">enableDAC</tt><big>(</big><em>channel</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.enableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>enableDAC(board,channel),</p>
<p>&#8216;board&#8217; can be the amda ID or device path,</p>
<p>&#8216;channel&#8217; is the channel number,</p>
<blockquote>
<div>reestablishes the DAC&#8217;s old values before it was switched off</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.getchannel">
<tt class="descname">getchannel</tt><big>(</big><em>channel</em>, <em>typ</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.getchannel" title="Permalink to this definition">¶</a></dt>
<dd><p>getchannel(board,channel,typ) ,</p>
<p>&#8216;board&#8217; can be the amda ID or device path,</p>
<p>&#8216;channel&#8217; is the channel number,</p>
<p>&#8216;typ&#8217; is either &#8216;dac&#8217; or &#8216;BG&#8217;</p>
<p>This function returns the values on the channel (from the ram)</p>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.interpret">
<tt class="descname">interpret</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.interpret" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.restart">
<tt class="descname">restart</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>reset(board),</p>
<p>&#8216;board&#8217; can be the amda ID or device path,</p>
<blockquote>
<div>resets the board controller</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.setBiasBuffer">
<tt class="descname">setBiasBuffer</tt><big>(</big><em>board</em>, <em>bufferLength</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.setBiasBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;board&#8217; can be the amda ID or device path,</p>
<blockquote>
<div>&#8216;bb&#8217; is the buffer bits on the bias gen and defaults to FF on the firmware</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.setExtraBits">
<tt class="descname">setExtraBits</tt><big>(</big><em>board</em>, <em>extraBits</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.setExtraBits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;board&#8217; can be the amda ID or device path,</p>
<blockquote>
<div>&#8216;extraBits&#8217; is the number of extra bits and defaults to 4 on the firmware</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.setchannel">
<tt class="descname">setchannel</tt><big>(</big><em>channel</em>, <em>normv</em>, <em>typ</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.setchannel" title="Permalink to this definition">¶</a></dt>
<dd><p>setchannel(board,channel,normv,typ) ,
&#8216;board&#8217; can be the amda ID or device path, 
&#8216;channel&#8217; is the channel number, 
&#8216;normv&#8217; is the value to be set normalised(0-1) with respect to the vdd. 
&#8216;typ&#8217; is either &#8216;dac&#8217; or &#8216;BG&#8217;</p>
<p>This function sets the values to the ram. You need to commit() in order to get these value to be actually set</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyAMDA.AMDA.AmdaClient">
<em class="property">class </em><tt class="descclassname">pyAMDA.AMDA.</tt><tt class="descname">AmdaClient</tt><big>(</big><em>host</em>, <em>board</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaClient" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyAMDA.AMDA.AmdaClient.cmd">
<tt class="descname">cmd</tt><big>(</big><em>command</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaClient.cmd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyAMDA.AMDA.AmdaClient.isopen">
<tt class="descname">isopen</tt><a class="headerlink" href="#pyAMDA.AMDA.AmdaClient.isopen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pyAMDA.AMDA.TimeOutException">
<em class="property">exception </em><tt class="descclassname">pyAMDA.AMDA.</tt><tt class="descname">TimeOutException</tt><a class="headerlink" href="#pyAMDA.AMDA.TimeOutException" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception for time out</p>
</dd></dl>

<dl class="function">
<dt id="pyAMDA.AMDA.cmdamda">
<tt class="descclassname">pyAMDA.AMDA.</tt><tt class="descname">cmdamda</tt><big>(</big><em>board</em>, <em>command</em>, <em>wait=False</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.cmdamda" title="Permalink to this definition">¶</a></dt>
<dd><p>cmdamda(board,command)</p>
<dl class="docutils">
<dt>sends the &#8216;command&#8217; string to the device and returns the output back.</dt>
<dd>the &#8216;board&#8217; can either be the path to the device, or just the device ID.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyAMDA.AMDA.result">
<tt class="descclassname">pyAMDA.AMDA.</tt><tt class="descname">result</tt><big>(</big><em>cmdoutput) returns just the actual output(to the right of the '=') from the whole string obtained from the cmdamda(</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.result" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyAex">
<span id="pyaex"></span><h2>pyAex<a class="headerlink" href="#module-pyAex" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyAexServer">
<span id="pyaexserver"></span><h2>pyAexServer<a class="headerlink" href="#module-pyAexServer" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pyAexServer.AexServer"></span><p>AexServer</p>
<blockquote>
<div><p>&#64;author: Daniel Sonnleithner
&#64;contact: <a class="reference external" href="mailto:daniel&#46;sonnleithner&#37;&#52;&#48;ini&#46;phys&#46;ethz&#46;ch">daniel<span>&#46;</span>sonnleithner<span>&#64;</span>ini<span>&#46;</span>phys<span>&#46;</span>ethz<span>&#46;</span>ch</a>
&#64;organization: Institute of Neuroinformatics</p>
<p>&#64;copyright: (c) by Daniel Sonnleithner</p>
<p>Created on: Aug 19, 2009</p>
<p>&#64;version: 0.1</p>
<p>Main logic for AexServer</p>
<p>Change log:</p>
</div></blockquote>
<dl class="class">
<dt id="pyAexServer.AexServer.AexServer">
<em class="property">class </em><tt class="descclassname">pyAexServer.AexServer.</tt><tt class="descname">AexServer</tt><big>(</big><em>aexDevice</em>, <em>monPort</em>, <em>stimPort</em>, <em>ctrlPort</em>, <em>prompt=True</em>, <em>debug=False</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.AexServer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyAexServer.AexServer.AexServer.aexfs_poll">
<tt class="descname">aexfs_poll</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.AexServer.aexfs_poll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.AexServer.AexServer.delayRetry">
<tt class="descname">delayRetry</tt><big>(</big><em>newDevice</em>, <em>delay</em>, <em>log</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.AexServer.delayRetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyAexServer.AexServer.AexServer.deviceLock">
<tt class="descname">deviceLock</tt><em class="property"> = &lt;thread.lock object at 0x6630e70&gt;</em><a class="headerlink" href="#pyAexServer.AexServer.AexServer.deviceLock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.AexServer.AexServer.log">
<tt class="descname">log</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.AexServer.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.AexServer.AexServer.openAexDevice">
<tt class="descname">openAexDevice</tt><big>(</big><em>aexDevice</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.AexServer.openAexDevice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.AexServer.AexServer.resetAexDevice">
<tt class="descname">resetAexDevice</tt><big>(</big><em>hold=False</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.AexServer.resetAexDevice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.AexServer.AexServer.resetNewAexDevice">
<tt class="descname">resetNewAexDevice</tt><big>(</big><em>newDevice</em>, <em>hold=False</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.AexServer.resetNewAexDevice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.AexServer.AexServer.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.AexServer.start" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.AexServer.AexServer.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.AexServer.stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyAexServer.AexServer.asyncCheckAction">
<em class="property">class </em><tt class="descclassname">pyAexServer.AexServer.</tt><tt class="descname">asyncCheckAction</tt><big>(</big><em>poll</em>, <em>action</em>, <em>log=None</em>, <em>interval=1.0</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.asyncCheckAction" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyAexServer.AexServer.asyncCheckAction.do">
<tt class="descname">do</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.asyncCheckAction.do" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.AexServer.asyncCheckAction.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.asyncCheckAction.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.AexServer.asyncCheckAction.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.asyncCheckAction.stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyAexServer.AexServer.heldlock">
<tt class="descclassname">pyAexServer.AexServer.</tt><tt class="descname">heldlock</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.heldlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyAexServer.AexServer.start_server">
<tt class="descclassname">pyAexServer.AexServer.</tt><tt class="descname">start_server</tt><big>(</big><em>dev_file='virtual'</em>, <em>prompt=False</em>, <em>monPort=50001</em>, <em>stimPort=50002</em>, <em>ctrlPort=50003</em>, <em>debug=True</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.start_server" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyAexServer.AexServer.stop_server">
<tt class="descclassname">pyAexServer.AexServer.</tt><tt class="descname">stop_server</tt><big>(</big><em>aexServer</em><big>)</big><a class="headerlink" href="#pyAexServer.AexServer.stop_server" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-pyAexServer.MonServer"></span><p>AexServer &#8211; MonServer</p>
<blockquote>
<div><p>&#64;author: Daniel Sonnleithner
&#64;contact: <a class="reference external" href="mailto:daniel&#46;sonnleithner&#37;&#52;&#48;ini&#46;phys&#46;ethz&#46;ch">daniel<span>&#46;</span>sonnleithner<span>&#64;</span>ini<span>&#46;</span>phys<span>&#46;</span>ethz<span>&#46;</span>ch</a>
&#64;organization: Institute of Neuroinformatics</p>
<p>&#64;copyright: (c) by Daniel Sonnleithner</p>
<p>Created on: Aug 19, 2009</p>
<p>&#64;version: 0.2</p>
<p>Provides access for many clients to the output of AEX boards</p>
<p>Change log:</p>
<p>11-06-06: filtering of events per client controlled by ControlServer</p>
</div></blockquote>
<dl class="class">
<dt id="pyAexServer.MonServer.MonNetCom">
<em class="property">class </em><tt class="descclassname">pyAexServer.MonServer.</tt><tt class="descname">MonNetCom</tt><big>(</big><em>request</em>, <em>client_address</em>, <em>server</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonNetCom" title="Permalink to this definition">¶</a></dt>
<dd><p>each time a client connects to the server, a new MonNetCom object is created that registers at the
server</p>
<dl class="method">
<dt id="pyAexServer.MonServer.MonNetCom.addMask">
<tt class="descname">addMask</tt><big>(</big><em>mask</em>, <em>checkValue</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonNetCom.addMask" title="Permalink to this definition">¶</a></dt>
<dd><p>add mask and checkValue -&gt; see sendData</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonNetCom.clearMasks">
<tt class="descname">clearMasks</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonNetCom.clearMasks" title="Permalink to this definition">¶</a></dt>
<dd><p>clears all masks and checkValues -&gt; see sendData</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonNetCom.finish">
<tt class="descname">finish</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonNetCom.finish" title="Permalink to this definition">¶</a></dt>
<dd><p>when closing the connection, this method is called. It tells the server to disconnect</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonNetCom.handle">
<tt class="descname">handle</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonNetCom.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>handles all incoming traffic. In the case of the MonServer it is more or less a placebo
method because nothing useful is done with incoming data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyAexServer.MonServer.MonNetCom.masklock">
<tt class="descname">masklock</tt><em class="property"> = &lt;thread.lock object at 0x6630db0&gt;</em><a class="headerlink" href="#pyAexServer.MonServer.MonNetCom.masklock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonNetCom.send">
<tt class="descname">send</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonNetCom.send" title="Permalink to this definition">¶</a></dt>
<dd><p>sends message (strings) to the client</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonNetCom.sendData">
<tt class="descname">sendData</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonNetCom.sendData" title="Permalink to this definition">¶</a></dt>
<dd><p>sends data (nparrays) to clients</p>
<p>provides the possibility to filter the addresses with given mask(s) and a checkValue(s)
first the mask is applied and then checked if it is identical to the checkValue; if so
these events are forwarded; all events where the addresses don&#8217;t match one of the given 
filter rules are not forwarded.</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonNetCom.setup">
<tt class="descname">setup</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonNetCom.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>when creating a connection, this method is called. It registers this object at the server</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyAexServer.MonServer.MonServer">
<em class="property">class </em><tt class="descclassname">pyAexServer.MonServer.</tt><tt class="descname">MonServer</tt><big>(</big><em>port</em>, <em>deviceFd</em>, <em>deviceLock</em>, <em>debug=False</em>, <em>aexServer=None</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer" title="Permalink to this definition">¶</a></dt>
<dd><p>classdocs</p>
<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.addMask">
<tt class="descname">addMask</tt><big>(</big><em>client</em>, <em>mask</em>, <em>checkValue</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.addMask" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.broadcast">
<tt class="descname">broadcast</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.broadcast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.broadcastData">
<tt class="descname">broadcastData</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.broadcastData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.clearMasks">
<tt class="descname">clearMasks</tt><big>(</big><em>client</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.clearMasks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyAexServer.MonServer.MonServer.clientsLock">
<tt class="descname">clientsLock</tt><em class="property"> = &lt;thread.lock object at 0x6630dd0&gt;</em><a class="headerlink" href="#pyAexServer.MonServer.MonServer.clientsLock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.connect">
<tt class="descname">connect</tt><big>(</big><em>client</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>When a new client is connecting to the server, a new NetControlCom object is created. 
This NetControlCom object then registers at the server with this connect method.</p>
<p>The client is put into the client database (self.__clients list).</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.disconnect">
<tt class="descname">disconnect</tt><big>(</big><em>client</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>When a client is disconnected from the server, the NetControlCom object calls this method.</p>
<p>The client is removed from the client database (self.__clients list)</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.log">
<tt class="descname">log</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.printClients">
<tt class="descname">printClients</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.printClients" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServer.updateFD">
<tt class="descname">updateFD</tt><big>(</big><em>deviceFD</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServer.updateFD" title="Permalink to this definition">¶</a></dt>
<dd><p>updates the current device file descriptor</p>
<p>ATTENTION: never call this function without having acquired the deviceLock!</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyAexServer.MonServer.MonServerStarter">
<em class="property">class </em><tt class="descclassname">pyAexServer.MonServer.</tt><tt class="descname">MonServerStarter</tt><big>(</big><em>port</em>, <em>deviceFd</em>, <em>deviceLock</em>, <em>debug=False</em>, <em>aexServer=None</em><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServerStarter" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyAexServer.MonServer.MonServerStarter.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServerStarter.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.MonServer.MonServerStarter.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.MonServer.MonServerStarter.stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-pyAexServer.StimServer"></span><p>AexServer &#8211; StimServer</p>
<blockquote>
<div><p>&#64;author: Daniel Sonnleithner
&#64;contact: <a class="reference external" href="mailto:daniel&#46;sonnleithner&#37;&#52;&#48;ini&#46;phys&#46;ethz&#46;ch">daniel<span>&#46;</span>sonnleithner<span>&#64;</span>ini<span>&#46;</span>phys<span>&#46;</span>ethz<span>&#46;</span>ch</a>
&#64;organization: Institute of Neuroinformatics</p>
<p>&#64;copyright: (c) by Daniel Sonnleithner</p>
<p>Created on: Aug 20, 2009</p>
<p>&#64;version: 0.1</p>
<p>Several clients can stimulate AEX boards at the same time using that server</p>
<p>Change log:</p>
</div></blockquote>
<dl class="class">
<dt id="pyAexServer.StimServer.StimNetCom">
<em class="property">class </em><tt class="descclassname">pyAexServer.StimServer.</tt><tt class="descname">StimNetCom</tt><big>(</big><em>request</em>, <em>client_address</em>, <em>server</em><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimNetCom" title="Permalink to this definition">¶</a></dt>
<dd><p>each time a client connects to the server, a new StimNetCom object is created that 
registers at the server</p>
<dl class="method">
<dt id="pyAexServer.StimServer.StimNetCom.finish">
<tt class="descname">finish</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimNetCom.finish" title="Permalink to this definition">¶</a></dt>
<dd><p>when closing the connection, this method is called. It tells the server to disconnect</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimNetCom.handle">
<tt class="descname">handle</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimNetCom.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>handles all incoming data</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimNetCom.setup">
<tt class="descname">setup</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimNetCom.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>when creating a connection, this method is called. It registers this object at the server</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyAexServer.StimServer.StimServer">
<em class="property">class </em><tt class="descclassname">pyAexServer.StimServer.</tt><tt class="descname">StimServer</tt><big>(</big><em>port</em>, <em>deviceFd</em>, <em>deviceLock</em>, <em>debug=False</em>, <em>aexServer=None</em><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServer" title="Permalink to this definition">¶</a></dt>
<dd><p>classdocs</p>
<dl class="attribute">
<dt id="pyAexServer.StimServer.StimServer.clientsLock">
<tt class="descname">clientsLock</tt><em class="property"> = &lt;thread.lock object at 0x6630df0&gt;</em><a class="headerlink" href="#pyAexServer.StimServer.StimServer.clientsLock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimServer.connect">
<tt class="descname">connect</tt><big>(</big><em>client</em><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServer.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>When a new client is connecting to the server, a new NetControlCom object is created. 
This NetControlCom object then registers at the server with this connect method.</p>
<p>The client is put into the client database (self.__clients list).</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimServer.disconnect">
<tt class="descname">disconnect</tt><big>(</big><em>client</em><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServer.disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>When a client is disconnected from the server, the NetControlCom object calls this method.</p>
<p>The client is removed from the client database (self.__clients list)</p>
</dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimServer.log">
<tt class="descname">log</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServer.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimServer.printClients">
<tt class="descname">printClients</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServer.printClients" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimServer.putData">
<tt class="descname">putData</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServer.putData" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a data into the data queue</p>
</dd></dl>

<dl class="attribute">
<dt id="pyAexServer.StimServer.StimServer.queueHasNewElement">
<tt class="descname">queueHasNewElement</tt><em class="property"> = &lt;threading._Event object at 0x7621f50&gt;</em><a class="headerlink" href="#pyAexServer.StimServer.StimServer.queueHasNewElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimServer.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServer.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimServer.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServer.stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimServer.updateFD">
<tt class="descname">updateFD</tt><big>(</big><em>deviceFD</em><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServer.updateFD" title="Permalink to this definition">¶</a></dt>
<dd><p>updates the current device file descriptor</p>
<p>ATTENTION: never call this function without having acquired the deviceLock!</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyAexServer.StimServer.StimServerStarter">
<em class="property">class </em><tt class="descclassname">pyAexServer.StimServer.</tt><tt class="descname">StimServerStarter</tt><big>(</big><em>port</em>, <em>deviceFd</em>, <em>deviceLock</em>, <em>debug=False</em>, <em>aexServer=None</em><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServerStarter" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyAexServer.StimServer.StimServerStarter.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServerStarter.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAexServer.StimServer.StimServerStarter.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAexServer.StimServer.StimServerStarter.stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-pyAexServer.ServerStarter"></span><dl class="function">
<dt id="pyAexServer.ServerStarter.start_server">
<tt class="descclassname">pyAexServer.ServerStarter.</tt><tt class="descname">start_server</tt><big>(</big><em>dev_file='virtual'</em>, <em>prompt=False</em>, <em>monPort=50001</em>, <em>stimPort=50002</em>, <em>ctrlPort=50003</em>, <em>debug=True</em><big>)</big><a class="headerlink" href="#pyAexServer.ServerStarter.start_server" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyAexServer.ServerStarter.stop_server">
<tt class="descclassname">pyAexServer.ServerStarter.</tt><tt class="descname">stop_server</tt><big>(</big><em>aexServer</em><big>)</big><a class="headerlink" href="#pyAexServer.ServerStarter.stop_server" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="pyst">
<h2>pyST<a class="headerlink" href="#pyst" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pyST"></span><dl class="attribute">
<dt id="pyST.STChannelAddressing">
<tt class="descclassname">pyST.</tt><tt class="descname">STChannelAddressing</tt><a class="headerlink" href="#pyST.STChannelAddressing" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">channelAddressing</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="pyST.STCompositePlot">
<tt class="descclassname">pyST.</tt><tt class="descname">STCompositePlot</tt><big>(</big><em>SL</em>, <em>id_list=None</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>t_start_rate=None</em>, <em>t_stop_rate=None</em>, <em>display=True</em>, <em>kwargs={}</em>, <em>kwargs_bar={}</em><big>)</big><a class="headerlink" href="#pyST.STCompositePlot" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a nice Composite plot, <em>i.e.</em> a raster plot combined with a vertical rate plot.</p>
<p>The arguments are identical to STPlotRaster, except for display. 
<em>display</em> If True is given a new figure is created. If [axS,axR] is given, where axS and axR are pylab.axes objects, then the spike rater and the rate plot are plotted there.</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STCreate">
<tt class="descclassname">pyST.</tt><tt class="descname">STCreate</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STCreate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyST.STPlotRaster">
<tt class="descclassname">pyST.</tt><tt class="descname">STPlotRaster</tt><big>(</big><em>SL</em>, <em>id_list=None</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>display=True</em>, <em>id_color=None</em>, <em>kwargs={}</em><big>)</big><a class="headerlink" href="#pyST.STPlotRaster" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as spikelist.raster_plot() but with pretty plot options</p>
<p>id_color is used to customize colors according to neuron address (for example inhibitory vs. excitatory)</p>
<p>Example:
&gt;&gt;&gt; id_color = [{&#8216;ids&#8217;:range(124),&#8217;color&#8217;:&#8217;blue&#8217;},{&#8216;ids&#8217;:range(124,128),&#8217;color&#8217;:&#8217;red&#8217;}]
&gt;&gt;&gt; plot_raster(chipout[158],id_color=id_color)</p>
</dd></dl>

<span class="target" id="module-pyST.STas"></span><dl class="class">
<dt id="pyST.STas.RawOutput">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">RawOutput</tt><big>(</big><em>raw_data</em>, <em>id_data</em>, <em>decoder_dict</em>, <em>t_start=0</em>, <em>t_stop=1000</em>, <em>filter_duplicates=False</em><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>RawOutPut is a class which contains raw AER data per channel (Physical addresses).</p>
<p>It decodes the AER data &#8220;just in time&#8221;</p>
<p>Inputs:
<em>raw_data</em>: events with physical addresses
<em>id_data</em>: all addresses in given channel
<em>decoder_dict</em>: Dictionary of functions for decoding addresses. Key designates the channel
<em>t_start</em>: start time of all spikelists in ms
<em>t_stop</em>: end time of all spikelists in ms
<em>filter_duplicates</em>: If True erases in all channels double events within the a 0.01ms time-frame (buggy hw)</p>
<p>Usage:
#In conjunction with pyAex.netClient</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">netClient</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">&#39;localhost&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_out</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">stimulate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">raw_output</span><span class="p">:</span> <span class="n">sl</span><span class="o">.</span><span class="n">raster_plot</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyST.STas.RawOutput.check_has_key_somewhere">
<tt class="descname">check_has_key_somewhere</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.check_has_key_somewhere" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.RawOutput.decode_all_channels">
<tt class="descname">decode_all_channels</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.decode_all_channels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.RawOutput.decode_data">
<tt class="descname">decode_data</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.decode_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.RawOutput.iterchannels">
<tt class="descname">iterchannels</tt><big>(</big><em>channels</em><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.iterchannels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.RawOutput.iteritems">
<tt class="descname">iteritems</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.iteritems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.RawOutput.print_num_events">
<tt class="descname">print_num_events</tt><big>(</big><em>raw_data</em><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.print_num_events" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyST.STas.STChannelAddressing">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">STChannelAddressing</tt><a class="headerlink" href="#pyST.STas.STChannelAddressing" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyST.STas.channelAddressing" title="pyST.STas.channelAddressing"><tt class="xref py py-class docutils literal"><span class="pre">channelAddressing</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrBuildHashTable">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrBuildHashTable</tt><big>(</big><em>stas</em><big>)</big><a class="headerlink" href="#pyST.STas.addrBuildHashTable" title="Permalink to this definition">¶</a></dt>
<dd><p>addrBuildHashTable(stas) constructs all possible physical addresses of the given address specification and stores it internally in its hash table (stas.addrExtractFast). This function is typically used for real-time monitoring</p>
<p><em>stas:</em> addrSpec object.</p>
<p><em>Hash tables are not used anymore</em></p>
<p>This function does not scale well.</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrLogicalConstruct">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrLogicalConstruct</tt><big>(</big><em>stas</em>, <em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addrLogicalConstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs Logical addresses, <em>i.e.</em> addresses in float format useful for plotting because they keep the neuron - synapse order.</p>
<p><strong>NOTE:</strong> Logical addresses do not contain channel information</p>
<p><em>addr</em>: address (in a form <a class="reference external" href="pyst.isValidAddress">isValidAddress</a> can understand)</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrLogicalExtract">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrLogicalExtract</tt><big>(</big><em>stas</em>, <em>addrLogical</em><big>)</big><a class="headerlink" href="#pyST.STas.addrLogicalExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Description here</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrLogicalPhysical">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrLogicalPhysical</tt><big>(</big><em>stas</em>, <em>addrLogical</em>, <em>checkLevel=1</em><big>)</big><a class="headerlink" href="#pyST.STas.addrLogicalPhysical" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct translation from Logical Addresses to Physical addresses using a hash table</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrLogicalPhysicalDecode">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrLogicalPhysicalDecode</tt><big>(</big><em>stas</em>, <em>addrLog</em><big>)</big><a class="headerlink" href="#pyST.STas.addrLogicalPhysicalDecode" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes logical addresses and fills the logical to physical hash table</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrPhysicalConstruct">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrPhysicalConstruct</tt><big>(</big><em>stas</em>, <em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addrPhysicalConstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Description here</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrPhysicalExtract">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrPhysicalExtract</tt><big>(</big><em>stas</em>, <em>addrPhys</em><big>)</big><a class="headerlink" href="#pyST.STas.addrPhysicalExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>addrPhysicalExtract takes a physical address as argument and returns a numpy array containing the human readable list of addresses. First dimension is the field type, second dimension is the address.
Uses hash tables for accelerating look-up.</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrPhysicalExtractDecode">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrPhysicalExtractDecode</tt><big>(</big><em>stas</em>, <em>addrPhys</em><big>)</big><a class="headerlink" href="#pyST.STas.addrPhysicalExtractDecode" title="Permalink to this definition">¶</a></dt>
<dd><p>addrPhysicalExtract takes a physical address as argument and returns a list containing the addresses in human readable form.
This is called only the first time the physical address is decoded.</p>
<p><em>stas:</em> addrSpec object.</p>
<p><em>addrPhys</em>: an integer or an iterable containing integers representing physical addresses</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrPhysicalLogical">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrPhysicalLogical</tt><big>(</big><em>stas</em>, <em>addrPhys</em>, <em>checkLevel=1</em><big>)</big><a class="headerlink" href="#pyST.STas.addrPhysicalLogical" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct translation from Physical Addresses to Logical addresses using a hash table</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrPhysicalLogicalDecode">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrPhysicalLogicalDecode</tt><big>(</big><em>stas</em>, <em>addrPhys</em><big>)</big><a class="headerlink" href="#pyST.STas.addrPhysicalLogicalDecode" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes physical addresses and fills the physical to logical hash table</p>
</dd></dl>

<dl class="class">
<dt id="pyST.STas.addrSpec">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">addrSpec</tt><big>(</big><em>addrStr=''</em>, <em>addrConf=</em><span class="optional">[</span><span class="optional">]</span>, <em>addrPinConf=''</em>, <em>id='NoName'</em><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Address specification class
# NOTE : Documentation is outdated!!</p>
<p><em>addrConf</em>: should be a list of dicts. Each dict should contain the following fields:</p>
<ul class="simple">
<li>&#8216;id&#8217;, whose value is equal to a single, unique, lowercase character.</li>
<li>&#8216;range&#8217;, an iterable containing the possible values the address field can take</li>
<li>&#8216;type&#8217;, which is either 1 (Neuron) or -1 (Synapse).</li>
</ul>
<p><em>addrStr</em>: should contain a list of space-separated pins with a number follwing an uppercase character defining the position on the chip. For example: &#8220;X0 X1 X2 X3 X4 X5 X6 Y4 Y3 Y2 Y1 Y0&#8221;</p>
<p><em>fe</em>: extraction function. this should be a string like &#8216;[X,Y*2]&#8217;, The letters must correspond to those in addrStr
<em>fc</em>: construction function &#8216;[x,y/2]&#8217;, the letters must corrspond to those in addrConf</p>
<p>fe(fc(a)) should be the identity function</p>
<p><em>IMPORTANT:</em> fe and fc are called vectorally (using numpy arrays), so check that the given functions also work with vectors (otherwise numpy.vstack will complain)</p>
<p><em>Example</em>:</p>
<dl class="method">
<dt id="pyST.STas.addrSpec.iter_fields">
<tt class="descname">iter_fields</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec.iter_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.addrSpec.iter_fields_by_pin">
<tt class="descname">iter_fields_by_pin</tt><big>(</big><em>pin_order=None</em><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec.iter_fields_by_pin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.addrSpec.iter_hrf_index">
<tt class="descname">iter_hrf_index</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec.iter_hrf_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over the indexes of addrConf</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.addrSpec.iter_hrfs">
<tt class="descname">iter_hrfs</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec.iter_hrfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over the list addrConf</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.addrSpec.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec.update" title="Permalink to this definition">¶</a></dt>
<dd><p>(Re)Generates the object based on the addrStr, addrConf and addrPinConf</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyST.STas.addressEncoder">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">addressEncoder</tt><big>(</big><em>addr_conf</em>, <em>addr_str</em>, <em>addr_pinconf</em><big>)</big><a class="headerlink" href="#pyST.STas.addressEncoder" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyST.STas.addressEncoder.decode">
<tt class="descname">decode</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addressEncoder.decode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.addressEncoder.decode_field">
<tt class="descname">decode_field</tt><big>(</big><em>field</em>, <em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addressEncoder.decode_field" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.addressEncoder.encode">
<tt class="descname">encode</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addressEncoder.encode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.addressEncoder.encode_field">
<tt class="descname">encode_field</tt><big>(</big><em>field</em>, <em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addressEncoder.encode_field" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyST.STas.channelAddressing">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">channelAddressing</tt><big>(</big><em>stasList, nChannelBits=[15, 16]</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing" title="Permalink to this definition">¶</a></dt>
<dd><p>This class contains the information defining the Channel Addressing Scheme for a multichip setup, i.e. definition of which chips are found on which channel</p>
<p>channelAddressing(stasList,nChannelBits)</p>
<p><em>nChannelBits</em>: Positions of channel bits in the hardware addresses. Default nChannelBits=[15,16]</p>
<p><em>stasList</em>: list of address specification objects, of the same length as len(nChannelBits)**2</p>
<p>See also:
<a class="reference external" href="#pyST.STas.addrSpec">addrSpec</a></p>
<dl class="method">
<dt id="pyST.STas.channelAddressing.addrLogicalConstruct">
<tt class="descname">addrLogicalConstruct</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.addrLogicalConstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs Logical addresses, <em>i.e.</em> addresses in float format useful for plotting because they keep the neuron - synapse order.</p>
<p>Returns a float32 numpy array.</p>
<p><strong>NOTE:</strong> Logical addresses do not contain channel information</p>
<p><em>addr</em>: address (in a form isChannelAddrList() can understand), such as <tt class="docutils literal"><span class="pre">{0:[range(15),2]}</span></tt></p>
<p>See also:</p>
<blockquote>
<div>addrLogicalConstruct, addrLogicalExtract</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.addrLogicalExtract">
<tt class="descname">addrLogicalExtract</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.addrLogicalExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts Logical Address with channel information</p>
<p><em>addr</em>: address (in a form isChannelAddrList() can understand), such as <tt class="docutils literal"><span class="pre">{0:[1.,2.,3.]}</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.addrPhysicalConstruct">
<tt class="descname">addrPhysicalConstruct</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.addrPhysicalConstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs Physical addresses to human readable addresses</p>
<p><em>addr</em>: numpy array of human readable numbers ( the physical addresses )</p>
<p><em>channel</em>: which channel addressing should be appended.</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.addrPhysicalExtract">
<tt class="descname">addrPhysicalExtract</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.addrPhysicalExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts Physical addresses to human readable addresses</p>
<p><em>addr</em>: numpy array of uint32 numbers ( the physical addresses )</p>
<p>Output is channelAddrList, channel where channelEventsList is a list of arrays which contain the addresses and channel is an array of channels.</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.addrPhysicalLogical">
<tt class="descname">addrPhysicalLogical</tt><big>(</big><em>addr</em>, <em>checkLevel=1</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.addrPhysicalLogical" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts Physical addresses to logical addresses (directly)</p>
<p><em>addr</em>: numpy array of uint32 numbers ( the physical addresses )</p>
<p>Output is channelAddrList, channel where channelEventsList is a list of arrays which contain the addresses and channel is an array of channels.</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.buildAllHashTables">
<tt class="descname">buildAllHashTables</tt><big>(</big><em>channels=None</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.buildAllHashTables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.exportAER">
<tt class="descname">exportAER</tt><big>(</big><em>spikeLists</em>, <em>filename=None</em>, <em>format='a'</em>, <em>isi=True</em>, <em>sep='t'</em>, <em>addr_format='%u'</em>, <em>time_format='%u'</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.exportAER" title="Permalink to this definition">¶</a></dt>
<dd><p>spikeLists can be a spikeList, a list of spikelists of dimension nChannels, a dictionary i.e.{channel: spikeList}. If a SpikeList is given, it will be equivalent to {0: spikeLists}.
format specifies whether timestamps (format=&#8217;t&#8217;) or addresses (format=&#8217;a&#8217;) should be on the first column.
<em>addr_format</em> and <em>time_format</em> format to be used by np.savetxt</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.extract">
<tt class="descname">extract</tt><big>(</big><em>ev</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the channel information from an array of hardware events. Returns a channelEvents object. Use addrPhysicalExtract for decoding the adresses instead.</p>
<p><em>eventsArray</em>: numpy array of hardware events (uint32)</p>
<dl class="docutils">
<dt>See also:</dt>
<dd>addrPhysicalExtract</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.generateST">
<tt class="descname">generateST</tt><big>(</big><em>ch_events</em>, <em>normalize=True</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.generateST" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts events from eventsChannel, using the address specification specified for the given channels, returns a list of SpikeList</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.getValue">
<tt class="descname">getValue</tt><big>(</big><em>channel</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the channel mask</p>
<p>channel: int between 0 and len(nChannelBits)**2</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.importAER">
<tt class="descname">importAER</tt><big>(</big><em>input=None</em>, <em>sep='t'</em>, <em>dt=1e-06</em>, <em>format='a'</em>, <em>isi=False</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.importAER" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal function for extracting, translating events from a numpy array. Output is a channelEvents dict</p>
<p><em>input</em>: if a string, will be treated as a filenam, if a numpy array, will be considered as events of dimension 2 x Nevents . By default addresses are on [:,0]</p>
<p><em>format</em>: either &#8216;t&#8217; or &#8216;a&#8217; respectively meaning timestamps and addresses on the first column. (&#8216;a&#8217; by default)</p>
<p><em>kwargs</em> are passed to np.loadtxt</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.isChannelAddrList">
<tt class="descname">isChannelAddrList</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.isChannelAddrList" title="Permalink to this definition">¶</a></dt>
<dd><p>Mostly internal function</p>
<p>Check whether addr is a valid channelAddr list/dict</p>
<p><em>addr</em>: Either list of dimension channelAddressing.nChannels, containing arrays of addresses. The list index is the channel number, or dict whose keys are the channel numbers.</p>
<p>See also:</p>
<blockquote>
<div>Stas.isValidAddress</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.normalizeAER">
<tt class="descname">normalizeAER</tt><big>(</big><em>ch_events</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.normalizeAER" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before extract to throw away pre-stimulus data</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.rawoutput_from_chevents">
<tt class="descname">rawoutput_from_chevents</tt><big>(</big><em>ch_events</em>, <em>func=None</em>, <em>normalize=True</em>, <em>filter_duplicates=False</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.rawoutput_from_chevents" title="Permalink to this definition">¶</a></dt>
<dd><p>this function acts like generateST, but constructs a RawOutput object which delays the decoding until it is necessary.
<em>ch_events</em> is a channelEvents object of type &#8216;p&#8217; (Physical)</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd><em>func</em> - a dictionary of functions with channels as keys to decode the addresses. If omitted, all the channels are considered</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyST.STas.channelEvents">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">channelEvents</tt><big>(</big><em>channel_events=None</em>, <em>atype='Physical'</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyST.STas.channelEvents.add_adtmch">
<tt class="descname">add_adtmch</tt><big>(</big><em>channel</em>, <em>ad</em>, <em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.add_adtmch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.add_ch">
<tt class="descname">add_ch</tt><big>(</big><em>channel</em>, <em>ev</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.add_ch" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an events object to a channel
Remark: Creates a reference to the provided events! In place changes also affect the events!</p>
</dd></dl>

<dl class="attribute">
<dt id="pyST.STas.channelEvents.atype">
<tt class="descname">atype</tt><a class="headerlink" href="#pyST.STas.channelEvents.atype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.filter_all_by_channel_mapping">
<tt class="descname">filter_all_by_channel_mapping</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.filter_all_by_channel_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies, in-place, the encapsulated events acccording to the one-to-many mapping (key is int/float, value is iterable)
In this function, a different mapping is used for each channel (useful for address that do not contain channel information, for example)</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.filter_all_by_mapping">
<tt class="descname">filter_all_by_mapping</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.filter_all_by_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies, in-place, the encapsulated events acccording to the one-to-many mapping (key is int/float, value is iterable)</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.filter_channel">
<tt class="descname">filter_channel</tt><big>(</big><em>channel_list=None</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.filter_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes (in-place) all channels with are not in channel_list.
If channel_list is omitted, the ch_events is left unchanged</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.flatten">
<tt class="descname">flatten</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.flatten" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.get_all_ad">
<tt class="descname">get_all_ad</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.get_all_ad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.get_all_adtmev">
<tt class="descname">get_all_adtmev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.get_all_adtmev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.get_all_tm">
<tt class="descname">get_all_tm</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.get_all_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.get_all_tmadev">
<tt class="descname">get_all_tmadev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.get_all_tmadev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.get_nev">
<tt class="descname">get_nev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.get_nev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.iter_by_timeslice">
<tt class="descname">iter_by_timeslice</tt><big>(</big><em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.iter_by_timeslice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyST.STas.events">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">events</tt><big>(</big><em>ev=None</em>, <em>atype='p'</em>, <em>isISI=False</em><big>)</big><a class="headerlink" href="#pyST.STas.events" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pyST.STas.events.NF">
<tt class="descname">NF</tt><em class="property"> = 2</em><a class="headerlink" href="#pyST.STas.events.NF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.ad">
<tt class="descname">ad</tt><a class="headerlink" href="#pyST.STas.events.ad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.add_adtm">
<tt class="descname">add_adtm</tt><big>(</big><em>ad</em>, <em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.events.add_adtm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.add_adtmev">
<tt class="descname">add_adtmev</tt><big>(</big><em>ev</em><big>)</big><a class="headerlink" href="#pyST.STas.events.add_adtmev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.atype">
<tt class="descname">atype</tt><a class="headerlink" href="#pyST.STas.events.atype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyST.STas.events.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.demultiplex">
<tt class="descname">demultiplex</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.demultiplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a dictionary with addesses as keys and a list of timestamps as values. 
Used internally for generating SpikeLists</p>
</dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#pyST.STas.events.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.empty">
<tt class="descname">empty</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.filter_by_mapping">
<tt class="descname">filter_by_mapping</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#pyST.STas.events.filter_by_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the events, given a mapping dictionary like:
map[src]=[target1,target2,...,targetn],</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_ad">
<tt class="descname">get_ad</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_ad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_adISI">
<tt class="descname">get_adISI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_adISI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_adtm">
<tt class="descname">get_adtm</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_adtm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_adtmev">
<tt class="descname">get_adtmev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_adtmev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_nev">
<tt class="descname">get_nev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_nev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_t_stop">
<tt class="descname">get_t_stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_t_stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_tdur">
<tt class="descname">get_tdur</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_tdur" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_tm">
<tt class="descname">get_tm</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_tmad">
<tt class="descname">get_tmad</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_tmad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_tmadev">
<tt class="descname">get_tmadev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_tmadev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.iter_by_timeslice">
<tt class="descname">iter_by_timeslice</tt><big>(</big><em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.events.iter_by_timeslice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.nev">
<tt class="descname">nev</tt><a class="headerlink" href="#pyST.STas.events.nev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.normalize_tm">
<tt class="descname">normalize_tm</tt><big>(</big><em>t0=0</em><big>)</big><a class="headerlink" href="#pyST.STas.events.normalize_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.set_abs_tm">
<tt class="descname">set_abs_tm</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.set_abs_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.set_ad">
<tt class="descname">set_ad</tt><big>(</big><em>ad</em><big>)</big><a class="headerlink" href="#pyST.STas.events.set_ad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.set_data">
<tt class="descname">set_data</tt><big>(</big><em>ad</em>, <em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.events.set_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.set_isi">
<tt class="descname">set_isi</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.set_isi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.set_tm">
<tt class="descname">set_tm</tt><big>(</big><em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.events.set_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.sort">
<tt class="descname">sort</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort events by addresses and timestamps (in this order).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.t_stop">
<tt class="descname">t_stop</tt><a class="headerlink" href="#pyST.STas.events.t_stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.tdur">
<tt class="descname">tdur</tt><a class="headerlink" href="#pyST.STas.events.tdur" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.tm">
<tt class="descname">tm</tt><a class="headerlink" href="#pyST.STas.events.tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyST.STas.extract_id_list">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">extract_id_list</tt><big>(</big><em>addr_conf</em><big>)</big><a class="headerlink" href="#pyST.STas.extract_id_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyST.STas.generateST">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">generateST</tt><big>(</big><em>stas</em>, <em>events</em>, <em>normalize=True</em><big>)</big><a class="headerlink" href="#pyST.STas.generateST" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts events from eventsChannel, using the address specification specified for the given channels, returns a list of SpikeList</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.getDefaultMonChannelAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">getDefaultMonChannelAddress</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.getDefaultMonChannelAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default Monitoring Channel Addressing Scheme (i.e. AER Output). No arguments</p>
<p>See also:
<a class="reference external" href="#pyST.STas.setDefaultMonChannelAddress">setDefaultMonChannelAddress</a></p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.getDefaultSeqChannelAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">getDefaultSeqChannelAddress</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.getDefaultSeqChannelAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default Monitoring Channel Addressing Scheme (i.e. AER Input). No arguments</p>
<p>See also:
<a class="reference external" href="#pyST.STas.setDefaultSeqChannelAddress">setDefaultSeqChannelAddress</a></p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.isValidAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">isValidAddress</tt><big>(</big><em>stas</em>, <em>addrList</em><big>)</big><a class="headerlink" href="#pyST.STas.isValidAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an internal function which verifies that the given &#8220;human readable&#8221; address is consistent with the address specification. It also takes care of &#8220;filling in&#8221; the addresses: for example [range(15),2] is understood as [range(15),[2]*15].</p>
<p>Raises AssertionError if addrList has incorrect data</p>
<p><em>stas</em>: an address specification object <a class="reference external" href="pyST.addrSpec">addrSpec</a>
<em>addrList</em>: a list of human readable addresses such as [range(15), 5]. It also accepts numpy arrays and transforms it accordingly</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.isValidPhysicalAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">isValidPhysicalAddress</tt><big>(</big><em>stas</em>, <em>addrPhys</em><big>)</big><a class="headerlink" href="#pyST.STas.isValidPhysicalAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the given list, int, numpy array is a valid physical address and outputs a numpy array</p>
</dd></dl>

<dl class="class">
<dt id="pyST.STas.layoutFieldEncoder">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">layoutFieldEncoder</tt><big>(</big><em>aspec</em>, <em>nWidth</em>, <em>position=0</em>, <em>pin=''</em><big>)</big><a class="headerlink" href="#pyST.STas.layoutFieldEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal struct used for addrSpec, performing the pin layout permutation (the information contained in addrSr)</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.load_stas_from_csv">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">load_stas_from_csv</tt><big>(</big><em>CSVfile</em><big>)</big><a class="headerlink" href="#pyST.STas.load_stas_from_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a reduced version of pyNCS.Chip._readCSV, which reads only the addressing information
Inputs:
<em>CSVfile</em> - A csv file describing the chip (a &#8220;chipfile&#8221;).</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.setDefaultMonChannelAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">setDefaultMonChannelAddress</tt><big>(</big><em>cs</em><big>)</big><a class="headerlink" href="#pyST.STas.setDefaultMonChannelAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default Monitoring Channel Addressing scheme (i.e. AER Output) in pyST globals, and used by pyAex. The argument is then returned when getDefaultMonChannelAddress is called</p>
<p>cs: The Channel Addressing Scheme, instance of the channelAddressing class</p>
<p>See also:
<a class="reference external" href="#pyST.STas.getDefaultMonChannelAddress">getDefaultMonChannelAddress</a></p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.setDefaultSeqChannelAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">setDefaultSeqChannelAddress</tt><big>(</big><em>cs</em><big>)</big><a class="headerlink" href="#pyST.STas.setDefaultSeqChannelAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default Sequencer Channel Addressing scheme (i.e. AER Input) in pyST globals, and used by pyAex. The argument is then returned when getDefaultMonChannelAddress is called</p>
<p>cs: The Channel Addressing Scheme, instance of the channelAddressing class</p>
<p>See also:
<a class="reference external" href="#pyST.STas.getDefaultSeqChannelAddress">pyST.getDefaultSeqChannelAddress</a></p>
</dd></dl>

<span class="target" id="module-pyST.STsl"></span><dl class="function">
<dt id="pyST.STsl.STCompositePlot">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">STCompositePlot</tt><big>(</big><em>SL</em>, <em>id_list=None</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>t_start_rate=None</em>, <em>t_stop_rate=None</em>, <em>display=True</em>, <em>kwargs={}</em>, <em>kwargs_bar={}</em><big>)</big><a class="headerlink" href="#pyST.STsl.STCompositePlot" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a nice Composite plot, <em>i.e.</em> a raster plot combined with a vertical rate plot.</p>
<p>The arguments are identical to STPlotRaster, except for display. 
<em>display</em> If True is given a new figure is created. If [axS,axR] is given, where axS and axR are pylab.axes objects, then the spike rater and the rate plot are plotted there.</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.STPlotRaster">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">STPlotRaster</tt><big>(</big><em>SL</em>, <em>id_list=None</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>display=True</em>, <em>id_color=None</em>, <em>kwargs={}</em><big>)</big><a class="headerlink" href="#pyST.STsl.STPlotRaster" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as spikelist.raster_plot() but with pretty plot options</p>
<p>id_color is used to customize colors according to neuron address (for example inhibitory vs. excitatory)</p>
<p>Example:
&gt;&gt;&gt; id_color = [{&#8216;ids&#8217;:range(124),&#8217;color&#8217;:&#8217;blue&#8217;},{&#8216;ids&#8217;:range(124,128),&#8217;color&#8217;:&#8217;red&#8217;}]
&gt;&gt;&gt; plot_raster(chipout[158],id_color=id_color)</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.composite_plot">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">composite_plot</tt><big>(</big><em>SL</em>, <em>id_list=None</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>t_start_rate=None</em>, <em>t_stop_rate=None</em>, <em>display=True</em>, <em>kwargs={}</em>, <em>kwargs_bar={}</em><big>)</big><a class="headerlink" href="#pyST.STsl.composite_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a nice Composite plot, <em>i.e.</em> a raster plot combined with a vertical rate plot.</p>
<p>The arguments are identical to STPlotRaster, except for display. 
<em>display</em> If True is given a new figure is created. If [axS,axR] is given, where axS and axR are pylab.axes objects, then the spike rater and the rate plot are plotted there.</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.composite_plot_movie">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">composite_plot_movie</tt><big>(</big><em>SL</em>, <em>time_bin=10</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>output='animation.mpg'</em>, <em>bounds=(0</em>, <em>5)</em>, <em>fps=10</em>, <em>display=True</em>, <em>maxrate=None</em>, <em>ratebin=None</em>, <em>kwargs={}</em><big>)</big><a class="headerlink" href="#pyST.STsl.composite_plot_movie" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyST.STsl.composite_plot_superimposed">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">composite_plot_superimposed</tt><big>(</big><em>st_pre, st_post, kwargs={}, colors=['blue', 'k'], id_list=None, t_start=None, t_stop=None, t_start_rate=None, t_stop_rate=None, pre_rate_mult=1.0</em><big>)</big><a class="headerlink" href="#pyST.STsl.composite_plot_superimposed" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a nice Composite plot superimposing two spike trains, a raster plot combined with a vertical rate plot.  
<em>st_pre</em> and <em>st_post</em> are two SpikeLists. st_post will be plotted above st_pre
<em>colors</em> is a list specifying the respective colors for the bars and spikes for st_pre and st_post
<em>kwargs</em> are the keyword arguments for common plot arguments in the raster plots. Default is {&#8216;alpha&#8217;:0.7,&#8217;marker&#8217;:&#8217;,&#8217;} for st_pre and plot_raster defaults for st_post
<em>pre_rate_mult</em> is a float used for plotting the rates of st_pre on a different scale
other arguments are the same as in composite_plot</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.ksi">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">ksi</tt><big>(</big><em>SL</em>, <em>t_stop=800</em>, <em>pow_freq=None</em>, <em>t_bin=10.0</em><big>)</big><a class="headerlink" href="#pyST.STsl.ksi" title="Permalink to this definition">¶</a></dt>
<dd><p>Kuramoto Synchronization Index (KSI) (Kuaramoto 1984) for measuring phase coherency with respect to the strongest    freqeuncy of the population activity.</p>
<p>Returns ksi in the range (0,1). 0 meaning no cohrency and 1 meaning entirely coherent</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd>SL      - SpikeList of duration of at least t_stop
t_stop  - the end of the SpikeTrain (in ms)
t_bin   - time bin for computing population activity and spectrum
pow_freq- if given, this frequency is taken as the strongest frequency</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.mapSpikeListAddresses">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">mapSpikeListAddresses</tt><big>(</big><em>SL</em>, <em>mapping=None</em><big>)</big><a class="headerlink" href="#pyST.STsl.mapSpikeListAddresses" title="Permalink to this definition">¶</a></dt>
<dd><p>this function maps the addresses of a spike list into another using the given mapping. Useful for logical to physical translation and vice versa
SL=original spike list
mapping=dictionary containing address mapping, If mapping is None, then the addresses will be mapped onto a linear scale, i.e. range(len(SL.id_list()))</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.plot_raster">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">plot_raster</tt><big>(</big><em>SL</em>, <em>id_list=None</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>display=True</em>, <em>id_color=None</em>, <em>kwargs={}</em><big>)</big><a class="headerlink" href="#pyST.STsl.plot_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as spikelist.raster_plot() but with pretty plot options</p>
<p>id_color is used to customize colors according to neuron address (for example inhibitory vs. excitatory)</p>
<p>Example:
&gt;&gt;&gt; id_color = [{&#8216;ids&#8217;:range(124),&#8217;color&#8217;:&#8217;blue&#8217;},{&#8216;ids&#8217;:range(124,128),&#8217;color&#8217;:&#8217;red&#8217;}]
&gt;&gt;&gt; plot_raster(chipout[158],id_color=id_color)</p>
</dd></dl>

</div>
<div class="section" id="module-pyMap">
<span id="pymap"></span><h2>pyMap<a class="headerlink" href="#module-pyMap" title="Permalink to this headline">¶</a></h2>
<p>&#64;author <a class="reference external" href="mailto:andstein&#37;&#52;&#48;student&#46;ethz&#46;ch">andstein<span>&#64;</span>student<span>&#46;</span>ethz<span>&#46;</span>ch</a>
&#64;created january 2010
&#64;version 1.0471975511965976</p>
<p>some classes&amp;modules that should facilitate the mapping process :</p>
<ul class="simple">
<li><a href="#id10"><span class="problematic" id="id11">module-Mapping_</span></a> : a class to construct/load &amp; parse the mapping as it is found on the mapper</li>
<li><a href="#id12"><span class="problematic" id="id13">module-MappingGui_</span></a> : a graphical representation of the Mapping</li>
</ul>
<p><strong>Synopsis</strong> see the source-code of <a href="#id14"><span class="problematic" id="id15">pyMap.show_</span></a> further down</p>
<p><strong>Dependencies</strong></p>
<blockquote>
<div><ul class="simple">
<li>packages <tt class="docutils literal"><span class="pre">pyST</span></tt>, <tt class="docutils literal"><span class="pre">pyNCS</span></tt></li>
<li>you need to setup the default global monitor&amp;sequencer before using this</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="pyMap.rnd">
<tt class="descclassname">pyMap.</tt><tt class="descname">rnd</tt><big>(</big><big>)</big><a class="headerlink" href="#pyMap.rnd" title="Permalink to this definition">¶</a></dt>
<dd><p>random() -&gt; x in the interval [0, 1).</p>
</dd></dl>

<dl class="function">
<dt id="pyMap.show">
<tt class="descclassname">pyMap.</tt><tt class="descname">show</tt><big>(</big><em>setup</em>, <em>type='gauss'</em><big>)</big><a class="headerlink" href="#pyMap.show" title="Permalink to this definition">¶</a></dt>
<dd><p>call this method to visualize some samples mappings</p>
<p><tt class="docutils literal"><span class="pre">setup</span></tt> : a <tt class="docutils literal"><span class="pre">pyNCS.Setup</span></tt> object that specifies the chip-setup</p>
<p><tt class="docutils literal"><span class="pre">type</span></tt> : type of sample setting (e.g. retina-2d, many, gauss, tuturial)</p>
<p>returns a <tt class="docutils literal"><span class="pre">MappingGui</span></tt> object showing the specified mapping</p>
</dd></dl>

<dl class="function">
<dt id="pyMap.test">
<tt class="descclassname">pyMap.</tt><tt class="descname">test</tt><big>(</big><em>setup, client, srcid='dummy', srcaddr=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 0], dstid='dummy', dstaddr=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 1], visualize=False</em><big>)</big><a class="headerlink" href="#pyMap.test" title="Permalink to this definition">¶</a></dt>
<dd><p>checks the mapper, HW&lt;-&gt;SW interaction &#8211; in order to do this, it creates a new mapping
and sends some stimulus to the addresses specified further down (make sure those addresses
are either not in use or silent during the test) and counts the output after the mapper.
it thus ensures that the mapping works and actually maps the way it&#8217;s supposed to. the
mapping is restored after the test. in cause of an <strong>error</strong> an <tt class="docutils literal"><span class="pre">Exception</span></tt> is generated.</p>
<p><tt class="docutils literal"><span class="pre">setup</span></tt> : a pyNCS.Setup object</p>
<p><tt class="docutils literal"><span class="pre">client</span></tt> : pyAex.netMonStimEventsQueue to use for stimulation (None: usd direct STAEXIO)</p>
<p><tt class="docutils literal"><span class="pre">srcid</span></tt>,``dstid``,``srcaddr``,``dstaddr`` : mapping to use for stimulation</p>
<p><tt class="docutils literal"><span class="pre">visualize</span></tt> : set to True if you want rasterplots of input/output</p>
</dd></dl>

</div>
<div class="section" id="module-pyOsc">
<span id="pyosc"></span><h2>pyOsc<a class="headerlink" href="#module-pyOsc" title="Permalink to this headline">¶</a></h2>
<p>&#64;author <a class="reference external" href="mailto:andstein&#37;&#52;&#48;student&#46;ethz&#46;ch">andstein<span>&#64;</span>student<span>&#46;</span>ethz<span>&#46;</span>ch</a>
&#64;created 20100204
&#64;version 0.1</p>
<p><strong>OVERVIEW</strong></p>
<p>a general wrapper for an oscilloscope. initialize this class with
an actual oscilloscope-&#8216;driver&#8217; as single argument. this object
maintains all internal variables, initializes the actual driver and
wrappes every function call</p>
<p>some features:</p>
<blockquote>
<div><ul class="simple">
<li>configuring the card</li>
<li>triggering</li>
<li>asynchronous data acquisition</li>
<li>config load/save</li>
</ul>
</div></blockquote>
<p>units : <tt class="docutils literal"><span class="pre">milliseconds</span></tt> and <tt class="docutils literal"><span class="pre">millivolts</span></tt> are used unless specified otherwise</p>
<p><strong>Drivers</strong></p>
<p>use one of the provided drivers &#8211; these are contained in the submodules.
there may be important notes on the usage of the individual drivers, make
sure to read them before use...</p>
<dl class="class">
<dt id="pyOsc.Oscilloscope">
<em class="property">class </em><tt class="descclassname">pyOsc.</tt><tt class="descname">Oscilloscope</tt><big>(</big><em>driver</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope" title="Permalink to this definition">¶</a></dt>
<dd><p>a remark about variable/method naming:</p>
<ul class="simple">
<li>it&#8217;s not random</li>
<li>if you want to GET a value, call the corresponding function without
arguments &#8211; e.g. .sr(1024) sets the sample rate to 1khz whilst
.sr() returns the sample rate without changing anything</li>
<li>every method that sets arguments saves them in the dictionary
self.cfg; if a method takes more than one argument, they should
be named and they will be saved in the form of a dictionary</li>
<li>every method in the wrapper has a corresponding method in the
driver (apart from docfg, save, load)</li>
<li>for documentation&#8217;s sake, these methods are all written by hand</li>
</ul>
<dl class="method">
<dt id="pyOsc.Oscilloscope.average">
<tt class="descname">average</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.average" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>input : raw data as returned by .data()</li>
<li>output : raw data in same format but averaged over rounds</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.channels">
<tt class="descname">channels</tt><big>(</big><em>channels=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.channels" title="Permalink to this definition">¶</a></dt>
<dd><p>enables the given channels (list)</p>
<p>please initialize every channel with a range</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.channels_n">
<tt class="descname">channels_n</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.channels_n" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the number of channels of this oscilloscope</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.data">
<tt class="descname">data</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.data" title="Permalink to this definition">¶</a></dt>
<dd><p>get the data from a data acquisition started by start()</p>
<p>returns data in the form { channel:[samples] }</p>
<p>rounds are CONCATENATED</p>
<p>the samples are NOT converted into units</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.docfg">
<tt class="descname">docfg</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.docfg" title="Permalink to this definition">¶</a></dt>
<dd><p>passes the current configuration through the driver</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.done">
<tt class="descname">done</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.done" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if a data acquisition started by start() has finished</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.load" title="Permalink to this definition">¶</a></dt>
<dd><p>loads settings from a file</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.max_samples">
<tt class="descname">max_samples</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.max_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the maximal number of samples in the internal buffer of
the oscilloscope (when using blocking reading)</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.max_sr">
<tt class="descname">max_sr</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.max_sr" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the maximal sample rate supported by this device</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.names">
<tt class="descname">names</tt><big>(</big><em>names=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.names" title="Permalink to this definition">¶</a></dt>
<dd><p>set the channel names to something more meaningful</p>
<p>these will be used in plots etc</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.normalize">
<tt class="descname">normalize</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.normalize" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>input : raw data in the form { chann: [samples...] }</li>
<li>output : normalized data in the form { chann:[ [ms],[mv] ] }</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.plot">
<tt class="descname">plot</tt><big>(</big><em>data</em>, <em>decorate=False</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>plots data using matplotlib</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">data</span></tt> : may be data returned from .data(), .normalize() et al</li>
<li><tt class="docutils literal"><span class="pre">decorate</span></tt> : use only together with &#8216;raw&#8217; data, marks trigger, frame, etc</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.ranges">
<tt class="descname">ranges</tt><big>(</big><em>ranges=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the range of specified channels (in millivolts)</p>
<p>this range is in positive AND negative direction</p>
<p>ranges : a dictionary</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>resets the card to a defined state &#8211; automatically called upon initialization</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.rounds">
<tt class="descname">rounds</tt><big>(</big><em>rounds=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.rounds" title="Permalink to this definition">¶</a></dt>
<dd><p>record an event several times (for averaging etc)</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.sr">
<tt class="descname">sr</tt><big>(</big><em>sr=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.sr" title="Permalink to this definition">¶</a></dt>
<dd><p>set sample acquisition rate [Hz]</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.start">
<tt class="descname">start</tt><big>(</big><em>samples</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.start" title="Permalink to this definition">¶</a></dt>
<dd><p>starts a data acquisition</p>
<p>samples: number of samples per channel per round</p>
<p>see triggers(), setsr(), setrounds(), timeout() for additional options</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.status">
<tt class="descname">status</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.status" title="Permalink to this definition">¶</a></dt>
<dd><p>returns some status information</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stops the card &#8211; e.g. when triggering fails</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.store">
<tt class="descname">store</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.store" title="Permalink to this definition">¶</a></dt>
<dd><p>saves the settings to a file</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.timeout">
<tt class="descname">timeout</tt><big>(</big><em>timeout=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>get/set the timeout</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.trigger">
<tt class="descname">trigger</tt><big>(</big><em>chann</em>, <em>mode</em>, <em>limit</em>, <em>offset=0.2</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>convinience wrapper for the more powerful .triggers() method</p>
<p>if you just need a single trigger</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.triggers">
<tt class="descname">triggers</tt><big>(</big><em>triggers=None</em>, <em>offset=0.2</em>, <em>chaining='and'</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.triggers" title="Permalink to this definition">¶</a></dt>
<dd><p>defines the chain of triggers to be used</p>
<dl class="docutils">
<dt>triggers <span class="classifier-delimiter">:</span> <span class="classifier">a list of dictionaries in the form &#8211; specify an empty list for &#8220;software triggering&#8221;</span></dt>
<dd><ul class="first last">
<li><p class="first">chann : what channel this triggering applies to</p>
</li>
<li><dl class="first docutils">
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd><ul class="first last simple">
<li>on raising edge &#8216;/&#8217;</li>
<li>on falling edge &#8216;&#8217;</li>
<li>in between levels for &gt;xx ms &#8216;Ixx&#8217;</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">limit : level to trigger at in mV (tuple for &#8216;Ixx&#8217;)</p>
</li>
</ul>
</dd>
</dl>
<p>chaining : when the trigger chain is satisfied : &#8216;and&#8217; / &#8216;or&#8217;
offset : at what point in the registered window the trigging event</p>
<blockquote>
<div>will be displayed (.5: 50% pre-triggering data)</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyOsc.test">
<tt class="descclassname">pyOsc.</tt><tt class="descname">test</tt><big>(</big><em>osc</em><big>)</big><a class="headerlink" href="#pyOsc.test" title="Permalink to this definition">¶</a></dt>
<dd><p>call this function if you want to check the setup</p>
<p>it simply plots signals from the first four channels; connect something interesting...</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">osc</span></tt> : the oscilloscope to test - evtl try debug option of driver; channels,trigger etc are NOT modified</li>
<li><tt class="docutils literal"><span class="pre">trigger</span></tt> : tests triggering on Channel 0, raising edge a 0V</li>
</ul>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API reference</a><ul>
<li><a class="reference internal" href="#pyncs">pyNCS</a></li>
<li><a class="reference internal" href="#module-pyAMDA.AMDA">pyAMDA</a></li>
<li><a class="reference internal" href="#module-pyAex">pyAex</a></li>
<li><a class="reference internal" href="#module-pyAexServer">pyAexServer</a></li>
<li><a class="reference internal" href="#pyst">pyST</a></li>
<li><a class="reference internal" href="#module-pyMap">pyMap</a></li>
<li><a class="reference internal" href="#module-pyOsc">pyOsc</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../examples/reservoir.html"
                        title="previous chapter">Reservoir</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/general/api.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../examples/reservoir.html" title="Reservoir"
             >previous</a> |</li>
        <li><a href="../index.html">Python NCS tools 0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009, Emre Neftci, Sadique Sheik, Daniel Sonnleithner, Giacomo Indiveri.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>