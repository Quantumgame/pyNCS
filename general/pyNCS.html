

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyNCS Package &mdash; Python NCS tools 0.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Python NCS tools 0.2 documentation" href="../index.html" />
    <link rel="up" title="pyNCS" href="modules.html" />
    <link rel="next" title="AerViewer Package" href="pyNCS.AerViewer.html" />
    <link rel="prev" title="pyNCS" href="modules.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyNCS.AerViewer.html" title="AerViewer Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="pyNCS"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Python NCS tools 0.2 documentation</a> &raquo;</li>
          <li><a href="modules.html" accesskey="U">pyNCS</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pyncs-package">
<h1>pyNCS Package<a class="headerlink" href="#pyncs-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">pyNCS</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pyNCS.__init__"></span><dl class="attribute">
<dt id="pyNCS.__init__.DocInherit">
<tt class="descclassname">pyNCS.__init__.</tt><tt class="descname">DocInherit</tt><a class="headerlink" href="#pyNCS.__init__.DocInherit" title="Permalink to this definition">¶</a></dt>
<dd><p>Docstring inheriting method descriptor</p>
<p>The class itself is also used as a decorator</p>
<p>doc_inherit decorator</p>
<p>Usage:</p>
<dl class="docutils">
<dt>class Foo(object):</dt>
<dd><dl class="first last docutils">
<dt>def foo(self):</dt>
<dd>&#8220;Frobber&#8221;
pass</dd>
</dl>
</dd>
<dt>class Bar(Foo):</dt>
<dd><p class="first">&#64;doc_inherit
def foo(self):</p>
<blockquote class="last">
<div>pass</div></blockquote>
</dd>
</dl>
<p>Now, Bar.foo.__doc__ == Bar().foo.__doc__ == Foo.foo.__doc__ == &#8220;Frobber&#8221;</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.__init__.doc_inherit">
<tt class="descclassname">pyNCS.__init__.</tt><tt class="descname">doc_inherit</tt><a class="headerlink" href="#pyNCS.__init__.doc_inherit" title="Permalink to this definition">¶</a></dt>
<dd><p>Docstring inheriting method descriptor</p>
<p>The class itself is also used as a decorator</p>
<p>doc_inherit decorator</p>
<p>Usage:</p>
<dl class="docutils">
<dt>class Foo(object):</dt>
<dd><dl class="first last docutils">
<dt>def foo(self):</dt>
<dd>&#8220;Frobber&#8221;
pass</dd>
</dl>
</dd>
<dt>class Bar(Foo):</dt>
<dd><p class="first">&#64;doc_inherit
def foo(self):</p>
<blockquote class="last">
<div>pass</div></blockquote>
</dd>
</dl>
<p>Now, Bar.foo.__doc__ == Bar().foo.__doc__ == Foo.foo.__doc__ == &#8220;Frobber&#8221;</p>
</dd></dl>

</div>
<div class="section" id="module-pyNCS.ComAPI">
<span id="comapi-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">ComAPI</span></tt> Module<a class="headerlink" href="#module-pyNCS.ComAPI" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyNCS.ComAPI.BatchCommunicatorBase">
<em class="property">class </em><tt class="descclassname">pyNCS.ComAPI.</tt><tt class="descname">BatchCommunicatorBase</tt><a class="headerlink" href="#pyNCS.ComAPI.BatchCommunicatorBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyNCS.ComAPI.ResourceManagerBase" title="pyNCS.ComAPI.ResourceManagerBase"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.ComAPI.ResourceManagerBase</span></tt></a>, <a class="reference internal" href="#pyNCS.ComAPI.RecordableCommunicatorBase" title="pyNCS.ComAPI.RecordableCommunicatorBase"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.ComAPI.RecordableCommunicatorBase</span></tt></a></p>
<dl class="method">
<dt id="pyNCS.ComAPI.BatchCommunicatorBase.run">
<tt class="descname">run</tt><big>(</big><em>stimulus=None</em>, <em>duration=None</em>, <em>context_manager=None</em><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.BatchCommunicatorBase.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Stimulate the neuromorphic hardware with event stream <em>stimulus</em> and monitor it for <em>duration</em> ms
Input:
<em>stimulus</em>: a numpy array in (addr, time) format. Type should be uint32 (shape = (-1,2)).
<em>duration</em>: monitor duration.
<em>context_manager</em>: context manager used to wrap the stimulate function. Useful for syncing with external process.
Output: a numpy array in addr, time format. Type is uint32 (shape = (-1,2)).</p>
<p>Usage:
&gt;&gt;&gt; events = np.array([[0, 1],[100,200]], dtype=&#8217;uint32&#8217;) #addr, time format
&gt;&gt;&gt; run(events, 1500)</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyNCS.ComAPI.Communicator">
<tt class="descclassname">pyNCS.ComAPI.</tt><tt class="descname">Communicator</tt><a class="headerlink" href="#pyNCS.ComAPI.Communicator" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyNCS.ComAPI.BatchCommunicatorBase" title="pyNCS.ComAPI.BatchCommunicatorBase"><tt class="xref py py-class docutils literal"><span class="pre">BatchCommunicatorBase</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyNCS.ComAPI.ContinuousCommunicatorBase">
<em class="property">class </em><tt class="descclassname">pyNCS.ComAPI.</tt><tt class="descname">ContinuousCommunicatorBase</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.ContinuousCommunicatorBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyNCS.ComAPI.BatchCommunicatorBase" title="pyNCS.ComAPI.BatchCommunicatorBase"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.ComAPI.BatchCommunicatorBase</span></tt></a></p>
<dl class="method">
<dt id="pyNCS.ComAPI.ContinuousCommunicatorBase.mon">
<tt class="descname">mon</tt><big>(</big><em>duration</em><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.ContinuousCommunicatorBase.mon" title="Permalink to this definition">¶</a></dt>
<dd><p>Monitor the neuromorphic hardware for <em>duration</em> ms</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ComAPI.ContinuousCommunicatorBase.stim">
<tt class="descname">stim</tt><big>(</big><em>stimulus</em>, <em>duration=None</em>, <em>context_manager=None</em>, <em>**stim_kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.ContinuousCommunicatorBase.stim" title="Permalink to this definition">¶</a></dt>
<dd><p>Stimulate the neuromorphic hardware with event stream <em>stimulus</em> and monitor it for <em>duration</em> ms
Input:
<em>stimulus</em>: a numpy array in addr, time format. Type should be uint32 (shape = (-1,2)).
<em>duration</em>: monitor duration.
<em>context_manager</em>: context manager used to wrap the stimulate function. Useful for syncing with external process.
<a href="#id2"><span class="problematic" id="id3">**</span></a><em>stim_kwargs</em>: keyward arguments passed to the underlying stimulation modules</p>
<p>Output: a numpy array in addr, time format. Type is uint32 (shape = (-1,2)).
Usage:
&gt;&gt;&gt; events = np.array([0, 1],[100,200], dtype=&#8217;uint32&#8217;) #addr, time format
&gt;&gt;&gt; stim(events, 1500)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase">
<em class="property">class </em><tt class="descclassname">pyNCS.ComAPI.</tt><tt class="descname">RecordableCommunicatorBase</tt><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="attribute">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase.REC_FN_MON">
<tt class="descname">REC_FN_MON</tt><em class="property"> = 'mon'</em><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase.REC_FN_MON" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase.REC_FN_SEQ">
<tt class="descname">REC_FN_SEQ</tt><em class="property"> = 'seq'</em><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase.REC_FN_SEQ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase.REC_HEADER_MON">
<tt class="descname">REC_HEADER_MON</tt><em class="property"> = '# File format raw address, timestamp (us)'</em><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase.REC_HEADER_MON" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase.REC_HEADER_SEQ">
<tt class="descname">REC_HEADER_SEQ</tt><em class="property"> = '# File format raw address, ISI (us)'</em><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase.REC_HEADER_SEQ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase.REC_PATH">
<tt class="descname">REC_PATH</tt><em class="property"> = '/tmp/exp_rec'</em><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase.REC_PATH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase.del_all">
<tt class="descname">del_all</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase.del_all" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase.get_exp_rec">
<tt class="descname">get_exp_rec</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase.get_exp_rec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the filename where the raw stimated and monitored events are saved.
The filenames for all experiments are returned, and run_id is reset</p>
<p>Output: list of filenames containing the experiment records (stimulated and monitored events). Additionally, the experiment number is reset.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase.run">
<tt class="descname">run</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.ComAPI.RecordableCommunicatorBase.run_rec">
<tt class="descname">run_rec</tt><big>(</big><em>stimulus=None</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.RecordableCommunicatorBase.run_rec" title="Permalink to this definition">¶</a></dt>
<dd><p>Stimulate the neuromorphic hardware with event stream <em>stimulus</em> and monitor it for <em>duration</em> ms.
In addition to the run() function, this function records the experimental data in /tmp/.
The resulting files can be obtained with get_exp_record
This function should be overridden to avoid redundant events file creation.</p>
<p>Input: (see also run() for more information)
<em>stimulus</em>: a numpy array in (addr, time) format. Type should be uint32 (shape = (-1,2)).
<em>duration</em>: monitor duration.
<em>context_manager</em>: context manager used to wrap the stimulate function. Useful for syncing with external process.
Output: a numpy array in addr, time format. Type is uint32 (shape = (-1,2)).</p>
<p>Usage:
&gt;&gt;&gt; events = np.array([[0, 1],[100,200]], dtype=&#8217;uint32&#8217;) #addr, time format
&gt;&gt;&gt; run_record(events, 1500)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.ComAPI.ResourceManagerBase">
<em class="property">class </em><tt class="descclassname">pyNCS.ComAPI.</tt><tt class="descname">ResourceManagerBase</tt><a class="headerlink" href="#pyNCS.ComAPI.ResourceManagerBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The ResourceManagerBase class is a base class for opening, closing a resource. It is used as parent classes for the configuration, communication and mapping APIs.
The init function takes no arguments by default</p>
<dl class="method">
<dt id="pyNCS.ComAPI.ResourceManagerBase.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.ResourceManagerBase.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes resource</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.ComAPI.ResourceManagerBase.isopen">
<tt class="descname">isopen</tt><a class="headerlink" href="#pyNCS.ComAPI.ResourceManagerBase.isopen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.ComAPI.ResourceManagerBase.open">
<tt class="descname">open</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ComAPI.ResourceManagerBase.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens resource</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyNCS.ConfAPI">
<span id="confapi-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">ConfAPI</span></tt> Module<a class="headerlink" href="#module-pyNCS.ConfAPI" title="Permalink to this headline">¶</a></h2>
<dl class="attribute">
<dt id="pyNCS.ConfAPI.Configurator">
<tt class="descclassname">pyNCS.ConfAPI.</tt><tt class="descname">Configurator</tt><a class="headerlink" href="#pyNCS.ConfAPI.Configurator" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyNCS.ConfAPI.ConfiguratorBase" title="pyNCS.ConfAPI.ConfiguratorBase"><tt class="xref py py-class docutils literal"><span class="pre">ConfiguratorBase</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyNCS.ConfAPI.ConfiguratorBase">
<em class="property">class </em><tt class="descclassname">pyNCS.ConfAPI.</tt><tt class="descname">ConfiguratorBase</tt><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyNCS.ComAPI.ResourceManagerBase" title="pyNCS.ComAPI.ResourceManagerBase"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.ComAPI.ResourceManagerBase</span></tt></a></p>
<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.add_parameter">
<tt class="descname">add_parameter</tt><big>(</big><em>param</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.add_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a parameter to the configurator
param: dictionary with all attributes of parameter or an xml element or
file name with the &lt;parameter /&gt; element</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.context_get_param">
<tt class="descname">context_get_param</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.context_get_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience contextmanager:
Context used when getting parameter object</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.get_param_names">
<tt class="descname">get_param_names</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.get_param_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns names of all the parameters</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.get_parameter">
<tt class="descname">get_parameter</tt><big>(</big><em>param_name</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.get_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets parameter param_name.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.get_parameters">
<tt class="descname">get_parameters</tt><big>(</big><em>param_names=None</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns parameters (dictionary of name-value pairs).
Input:
<em>param_names:</em> A list of parameter names
If param_names is None, then this function returns all the parameters
(using self.get_param_names())</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.neurosetup">
<tt class="descname">neurosetup</tt><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.neurosetup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.register_neurosetup">
<tt class="descname">register_neurosetup</tt><big>(</big><em>neurosetup</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.register_neurosetup" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a link to the Neurosetup. This is useful for complex parameter
configuration protocols requiring the sequencing and monitoring of
address-events</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all the parameters to default values</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.save_parameters">
<tt class="descname">save_parameters</tt><big>(</big><em>filename</em>, <em>*kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.save_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves parameters to a file</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.set_parameter">
<tt class="descname">set_parameter</tt><big>(</big><em>param_name</em>, <em>param_value</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.set_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets parameter param_name with param_value</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.set_parameters">
<tt class="descname">set_parameters</tt><big>(</big><em>param_dict</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.set_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set several parameters using a dictionary.
Input:
<em>param_dict</em>: dictionary of parameter names (str) - value (float) pairs.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.ConfiguratorBase.update_parameter">
<tt class="descname">update_parameter</tt><big>(</big><em>param_name</em>, <em>param_value</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.ConfiguratorBase.update_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Update/Inform the object of changes made from other clients.
Input:</p>
<blockquote>
<div><em>param_name</em>: Parameter name
<em>param_value</em>: Parameter value</div></blockquote>
<p>Ideal to use when the parameters can be changed from multiple clients
simultaneously.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyNCS.ConfAPI.Mappings">
<tt class="descclassname">pyNCS.ConfAPI.</tt><tt class="descname">Mappings</tt><a class="headerlink" href="#pyNCS.ConfAPI.Mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyNCS.ConfAPI.MappingsBase" title="pyNCS.ConfAPI.MappingsBase"><tt class="xref py py-class docutils literal"><span class="pre">MappingsBase</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="pyNCS.ConfAPI.MappingsBase">
<em class="property">class </em><tt class="descclassname">pyNCS.ConfAPI.</tt><tt class="descname">MappingsBase</tt><a class="headerlink" href="#pyNCS.ConfAPI.MappingsBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyNCS.ComAPI.ResourceManagerBase" title="pyNCS.ComAPI.ResourceManagerBase"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.ComAPI.ResourceManagerBase</span></tt></a></p>
<dl class="method">
<dt id="pyNCS.ConfAPI.MappingsBase.add_mappings">
<tt class="descname">add_mappings</tt><big>(</big><em>mappings</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.MappingsBase.add_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <em>mappings</em> to the mappings table.</p>
<p>Inputs:
<em>mappings</em>: a two-dimenstional iterable</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.MappingsBase.clear_mappings">
<tt class="descname">clear_mappings</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.MappingsBase.clear_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the mapping table. No inputs</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.MappingsBase.del_mappings">
<tt class="descname">del_mappings</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.MappingsBase.del_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the mapping table. No inputs</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.MappingsBase.get_mappings">
<tt class="descname">get_mappings</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.MappingsBase.get_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array representing the mappings</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.MappingsBase.set_mappings">
<tt class="descname">set_mappings</tt><big>(</big><em>mappings</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.MappingsBase.set_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the mapping table and adds <em>mappings</em> to the mappings table.</p>
<p>Inputs:
<em>mappings</em>: a two-dimenstional iterable</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.ConfAPI.Parameter">
<em class="property">class </em><tt class="descclassname">pyNCS.ConfAPI.</tt><tt class="descname">Parameter</tt><big>(</big><em>parameters</em>, <em>configurator</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.Parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">traits.has_traits.HasTraits</span></tt></p>
<dl class="method">
<dt id="pyNCS.ConfAPI.Parameter.getValue">
<tt class="descname">getValue</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.Parameter.getValue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.ConfAPI.Parameter.setValue">
<tt class="descname">setValue</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyNCS.ConfAPI.Parameter.setValue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyNCS.chip_v2">
<span id="chip-v2-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">chip_v2</span></tt> Module<a class="headerlink" href="#module-pyNCS.chip_v2" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyNCS.chip_v2.Block">
<em class="property">class </em><tt class="descclassname">pyNCS.chip_v2.</tt><tt class="descname">Block</tt><big>(</big><em>neurochip</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyNCS.chip_v2.Chip">
<em class="property">class </em><tt class="descclassname">pyNCS.chip_v2.</tt><tt class="descname">Chip</tt><big>(</big><em>chipdoc</em>, <em>id='noname'</em>, <em>offline=False</em>, <em>conf_api=None</em>, <em>conf_kwargs={}</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyNCS.chip_v2.Chip.context_open">
<tt class="descname">context_open</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip.context_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Context for opening configurator only if necessary, and closing it if it had to be opened - leaves configurator in its previous state</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip_v2.Chip.get_param_names">
<tt class="descname">get_param_names</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip.get_param_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all bias names</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip_v2.Chip.get_parameter">
<tt class="descname">get_parameter</tt><big>(</big><em>param_name</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip.get_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set biases</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip_v2.Chip.get_parameters">
<tt class="descname">get_parameters</tt><big>(</big><em>param_names=None</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get bias values</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip_v2.Chip.grep_params">
<tt class="descname">grep_params</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip.grep_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all parameters and values containing the given string.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip_v2.Chip.load_parameters">
<tt class="descname">load_parameters</tt><big>(</big><em>CSVfile</em>, <em>sep='t'</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip.load_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>loadBiases(CSVfile) loads the bias valuess from the CSV file
created with saveBiases(CSVfile)</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip_v2.Chip.restart">
<tt class="descname">restart</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>Restart the chip</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip_v2.Chip.save_parameters">
<tt class="descname">save_parameters</tt><big>(</big><em>filename</em>, <em>*kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip.save_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves all the biases of the chip to a file</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip_v2.Chip.set_parameter">
<tt class="descname">set_parameter</tt><big>(</big><em>param_name</em>, <em>param_value</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip.set_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set biases</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip_v2.Chip.set_parameters">
<tt class="descname">set_parameters</tt><big>(</big><em>param_dict</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.Chip.set_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set biases</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.chip_v2.Chip.virtual">
<tt class="descname">virtual</tt><a class="headerlink" href="#pyNCS.chip_v2.Chip.virtual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.chip_v2.NeuroChip">
<em class="property">class </em><tt class="descclassname">pyNCS.chip_v2.</tt><tt class="descname">NeuroChip</tt><big>(</big><em>chipfile</em>, <em>id='noname'</em>, <em>offline=False</em>, <em>conf_api=None</em>, <em>conf_kwargs={}</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.NeuroChip" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyNCS.chip_v2.Chip" title="pyNCS.chip_v2.Chip"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.chip_v2.Chip</span></tt></a></p>
<dl class="method">
<dt id="pyNCS.chip_v2.NeuroChip.saveXML">
<tt class="descname">saveXML</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.NeuroChip.saveXML" title="Permalink to this definition">¶</a></dt>
<dd><p>save XML representation of this object to a file</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.chip_v2.NeuronBlock">
<em class="property">class </em><tt class="descclassname">pyNCS.chip_v2.</tt><tt class="descname">NeuronBlock</tt><big>(</big><em>neurochip</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.NeuronBlock" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyNCS.chip_v2.NeuronBlock.expand_dims">
<tt class="descname">expand_dims</tt><big>(</big><em>synapse=None</em><big>)</big><a class="headerlink" href="#pyNCS.chip_v2.NeuronBlock.expand_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of all addresses for the output (soma) type or the specified input (synapse).
WARNING: This is buggy! The order of the numbers matters! It should</p>
<blockquote>
<div>be coherent with the address specification!</div></blockquote>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyNCS.connection">
<span id="connection-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">connection</span></tt> Module<a class="headerlink" href="#module-pyNCS.connection" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyNCS.connection.Connection">
<em class="property">class </em><tt class="descclassname">pyNCS.connection.</tt><tt class="descname">Connection</tt><big>(</big><em>popsrc</em>, <em>popdst</em>, <em>synapse</em>, <em>fashion='one2one'</em>, <em>fashion_kwargs={}</em>, <em>append=True</em>, <em>setup=None</em><big>)</big><a class="headerlink" href="#pyNCS.connection.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A class representing the connections between populations.</p>
<dl class="method">
<dt id="pyNCS.connection.Connection.plot">
<tt class="descname">plot</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.connection.Connection.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>plots the connectivity</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.connection.PConnection">
<em class="property">class </em><tt class="descclassname">pyNCS.connection.</tt><tt class="descname">PConnection</tt><big>(</big><em>popsrc</em>, <em>popdst</em>, <em>synapse</em>, <em>fashion='one2one'</em>, <em>fashion_kwargs={}</em>, <em>append=True</em>, <em>setup=None</em><big>)</big><a class="headerlink" href="#pyNCS.connection.PConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyNCS.connection.Connection" title="pyNCS.connection.Connection"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.connection.Connection</span></tt></a></p>
</dd></dl>

</div>
<div class="section" id="module-pyNCS.experimentTools">
<span id="experimenttools-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">experimentTools</span></tt> Module<a class="headerlink" href="#module-pyNCS.experimentTools" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyNCS.experimentTools.annotate">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">annotate</tt><big>(</big><em>filename=''</em>, <em>text=''</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.annotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a file in the Results directory, with contents text</p>
</dd></dl>

<dl class="class">
<dt id="pyNCS.experimentTools.datacontainer">
<em class="property">class </em><tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">datacontainer</tt><a class="headerlink" href="#pyNCS.experimentTools.datacontainer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.get_figsize">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">get_figsize</tt><big>(</big><em>fig_width_pt</em>, <em>ratio='g'</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.get_figsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to generate figure size.</p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.load">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">load</tt><big>(</big><em>filename=None</em>, <em>compatibility=True</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpickles file named &#8216;filename&#8217; from the results directory. If no &#8216;filename&#8217; is given, then &#8216;globaldata.pickle&#8217; is loaded</p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.loadPlotParameters">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">loadPlotParameters</tt><big>(</big><em>size=0.5</em>, <em>fontsize=18.0</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.loadPlotParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Load default matplotlib parameters for pretty plotting
size: 0.5 &#8211; two column page.</p>
<blockquote>
<div>0.33 &#8211; three column page.
0.25 &#8211; two column double figure.</div></blockquote>
<p>fontsize: universal font size</p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.load_compatibility">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">load_compatibility</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.load_compatibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as experimentTools.load(), but works around recent module renaming problems
Code from <a class="reference external" href="http://wiki.python.org/moin/UsingPickle/RenamingModules">http://wiki.python.org/moin/UsingPickle/RenamingModules</a></p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.mksavedir">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">mksavedir</tt><big>(</big><em>pre='Results/'</em>, <em>exp_dir=None</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.mksavedir" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a results directory in the subdirectory &#8216;pre&#8217;. The directory name is given by ###__dd_mm_yy, where ### is the next unused 3 digit number</p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.save">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">save</tt><big>(</big><em>obj=None</em>, <em>filename=None</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.save_py_scripts">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">save_py_scripts</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.save_py_scripts" title="Permalink to this definition">¶</a></dt>
<dd><p>Save all the python scripts from the current directory into the results directory</p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.save_rec_files">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">save_rec_files</tt><big>(</big><em>nsetup</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.save_rec_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves files recorded by the communicator and prepends address specification</p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.savefig">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">savefig</tt><big>(</big><em>filename</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.savefig" title="Permalink to this definition">¶</a></dt>
<dd><p>Like pylab.savefig but appends the Results directory</p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.savefigs">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">savefigs</tt><big>(</big><em>filename='fig'</em>, <em>extension='png'</em>, <em>close=True</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.savefigs" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves all figures with filename <em>filename#</em> where # is the figure number.
The order is: last opened last saved.
Inputs:
<em>filename</em>: figure name prefix
<em>extension</em>: figure extension. savefig should resolve the format from the extension
<em>close</em>: whether to close the figure after it is saved
<a href="#id4"><span class="problematic" id="id5">*</span></a>args, <a href="#id6"><span class="problematic" id="id7">**</span></a>kwargs  are passed to savefig</p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.experimentTools.savetxt">
<tt class="descclassname">pyNCS.experimentTools.</tt><tt class="descname">savetxt</tt><big>(</big><em>obj</em>, <em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.experimentTools.savetxt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyNCS.group">
<span id="group-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">group</span></tt> Module<a class="headerlink" href="#module-pyNCS.group" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyNCS.group.AddrGroup">
<em class="property">class </em><tt class="descclassname">pyNCS.group.</tt><tt class="descname">AddrGroup</tt><big>(</big><em>name</em>, <em>description=None</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A AddrGroup is a group of chip addresses. They can be of grouptype &#8216;in&#8217; or of grouptype &#8216;out&#8217;. A description
is needed for populating the group.
AddrGroup lives in the setup, which means one can address neurons without caring about on which
chip.</p>
<dl class="docutils">
<dt>Ex.:</dt>
<dd><p class="first">setup = pyNCS.Setup(&#8216;setuptype.xml&#8217;)
setup.load(&#8216;setup&#8217;)
setup.apply()</p>
<p># output from the retina
group1 = AddrGroup(&#8216;retina output&#8217;)
group1.populate_rectangle(</p>
<blockquote>
<div>setup, &#8216;retina&#8217;, &#8216;out&#8217;, [0,0,0], [64,64,0], n = 28*28 )</div></blockquote>
<p># input from the retina
group2 = AddrGroup(&#8216;A1 cortex learning input&#8217;)
group2.populate_rectangle(setup, &#8216;ifslwta_0&#8217;, &#8216;in&#8217;, [0,4], [28,32])</p>
<p># input from the sequencer
group3 = AddrGroup(&#8216;A1 cortex excitatory input&#8217;)
group3.populate_rectangle(setup, &#8216;ifslwta_0&#8217;, &#8216;in&#8217;, [0,2], [28,2])</p>
<p># input from the sequencer
group4 = AddrGroup(&#8216;A1 cortex excitatory inhibitory&#8217;)
group4.populate_rectangle(setup, &#8216;ifslwta_0&#8217;, &#8216;in&#8217;, [0,2], [28,2])</p>
<p>group5 = AddrGroup(&#8216;56 trains from sequencer&#8217;)
group4.populate_by_number(setup, &#8216;seq&#8217;, &#8216;out&#8217;, 56)</p>
<p># you want to treat group3 and group4 as a whole
group4.join_with(group3)</p>
<p>mapping = []
mapping = group1.connect_one2one(group2)</p>
<blockquote>
<div># the connect functions will maybe go in some Mapping module</div></blockquote>
<p># ... and so on and so forth ...</p>
<p class="last">setMappings(mapping)</p>
</dd>
</dl>
<dl class="method">
<dt id="pyNCS.group.AddrGroup.add">
<tt class="descname">add</tt><big>(</big><em>setup</em>, <em>addresses</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of addresses to a group.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.group.AddrGroup.ch_addr">
<tt class="descname">ch_addr</tt><a class="headerlink" href="#pyNCS.group.AddrGroup.ch_addr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.getLaddr">
<tt class="descname">getLaddr</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.getLaddr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.getPaddr">
<tt class="descname">getPaddr</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.getPaddr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.is_empty">
<tt class="descname">is_empty</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.is_empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyNCS.group.AddrGroup.laddr">
<tt class="descname">laddr</tt><a class="headerlink" href="#pyNCS.group.AddrGroup.laddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical addresses</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.group.AddrGroup.paddr">
<tt class="descname">paddr</tt><a class="headerlink" href="#pyNCS.group.AddrGroup.paddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Physical addresses</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.populate_by_number">
<tt class="descname">populate_by_number</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>grouptype</em>, <em>n</em>, <em>dims</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.populate_by_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate with the given number of neuron, doesn&#8217;t matter the shape.
Needs the number of dimensions
WARNING: This should go in upper layer of abstraction.
TODO: check if this function is unused (Reason: contains reference errors)</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.populate_circle">
<tt class="descname">populate_circle</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.populate_circle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.populate_line">
<tt class="descname">populate_line</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>grouptype</em>, <em>addresses</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.populate_line" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.populate_rectangle">
<tt class="descname">populate_rectangle</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>grouptype</em>, <em>p1</em>, <em>p2</em>, <em>z=None</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.populate_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate with all the neurons within the rectangle&#8217;s given coordinates. If n is given,
populate with the given number of neurons instead of all neurons in the rectangle.
z defines the 3d coordinate, e.g. retina polarity or synapse in the 2d chip.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.populate_rectangle_coarse">
<tt class="descname">populate_rectangle_coarse</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.populate_rectangle_coarse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.remove">
<tt class="descname">remove</tt><big>(</big><em>address</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove list of addresses to a group.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.repopulate">
<tt class="descname">repopulate</tt><big>(</big><em>setup</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.repopulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Repopulates laddr and paddr with respect to addr</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.setLaddr">
<tt class="descname">setLaddr</tt><big>(</big><em>ad</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.setLaddr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.setPaddr">
<tt class="descname">setPaddr</tt><big>(</big><em>ad</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.setPaddr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.sort">
<tt class="descname">sort</tt><big>(</big><em>order=None</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort all the addresses with the given order. If the order is None it
orders by the last column of the address (most probably the column of
synapses).</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.spiketrains">
<tt class="descname">spiketrains</tt><big>(</big><em>spikes=</em><span class="optional">[</span><span class="optional">]</span>, <em>t_start=0</em>, <em>t_stop=None</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.spiketrains" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a stimulus with the desired SpikeList.
spikes : list of tuples (id, time)
All the arguments are the same as that of a pyST.SpikeList</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.spiketrains_1D_bump">
<tt class="descname">spiketrains_1D_bump</tt><big>(</big><em>pos</em>, <em>width</em>, <em>ampl</em>, <em>t_start=0.0</em>, <em>duration=1000.0</em>, <em>channel=None</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.spiketrains_1D_bump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.spiketrains_inh_generator">
<tt class="descname">spiketrains_inh_generator</tt><big>(</big><em>rate</em>, <em>t</em>, <em>channel=None</em>, <em>base_generator=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.spiketrains_inh_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create inhomogeneous spiketrains.
The process is defined by the base_generator function. See pyST.STCreate for available functions.
Rate is a vector of rates.
The first dimension of rates corresponds to the neurons
The second dimension corresponds to the time bin. The length of this must be the same as t.
In addition, the rates <em>must</em> end with 0 to mark the end of the last bin.
keyword arguments kwargs are passed to the spiketrain generator.
See also pyST.STCreate.inh_poisson_generator
Kewword arguments are passed to the spike generator. Default is regular.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.spiketrains_inh_poisson">
<tt class="descname">spiketrains_inh_poisson</tt><big>(</big><em>rate</em>, <em>t</em>, <em>channel=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.spiketrains_inh_poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>Create inhomogeneous poisson spiketrains. Rate is a vector of rates.
The first dimension of rates corresponds to the neurons
The second dimension corresponds to the time bin. The length of this must be the same as t.
In addition, the rates <em>must</em> end with 0 to mark the end of the last bin.
keyword arguments kwargs are passed to the spiketrain generator.
See also pyST.STCreate.inh_poisson_generator</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.spiketrains_poisson">
<tt class="descname">spiketrains_poisson</tt><big>(</big><em>rate</em>, <em>t_start=0.0</em>, <em>duration=1000.0</em>, <em>channel=None</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.spiketrains_poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a poisson spiketrain for each address on the group.
You can use channel argument to enforce a particular channel.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.spiketrains_regular">
<tt class="descname">spiketrains_regular</tt><big>(</big><em>rate</em>, <em>offset=0.0</em>, <em>t_start=0.0</em>, <em>duration=1000.0</em>, <em>jitter=False</em>, <em>channel=None</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.spiketrains_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular spiketrain for each address on the group.
You can use channel argument to enforce a particular channel.
Use an offset vector to add an offset shift to the trains (must be a
vector).</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd>rate    - the rate of the discharge (in Hz). Can be an iterable
t_start - the beginning of the SpikeTrain (in ms)
offet   - Offset the spiketrain by this number (in ms.). Can be an iterable.
jitter  - whether the spiketrain should be jittered by an amount numpy.random.rand()/rate
duration- The duration of the SpikeTrain (in ms)
channel - Channel argument to enforce a particular channel</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.spiketrains_regular_gaussian">
<tt class="descname">spiketrains_regular_gaussian</tt><big>(</big><em>rate</em>, <em>offset=0.0</em>, <em>scale=5.0</em>, <em>t_start=0.0</em>, <em>duration=1000.0</em>, <em>channel=None</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.spiketrains_regular_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SpikeTrain whose spikes are regularly spaced, but jittered
according to a Gaussian distribution around the spiking period, with
the given rate (Hz) and stopping time t_stop (milliseconds).</p>
<p>Note: t_start is always 0.0, thus all realizations are as if they
spiked at t=0.0, though this spike is not included in the SpikeList.</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd><p class="first">rate    - the rate of the discharge (in Hz). Can be an iterable
t_start - the beginning of the SpikeTrain (in ms)
phase   - Use an offset vector to add an offset shift to the spike trains. Can be an iterable
scale   - width of the Gaussian distribution placed at the regular</p>
<blockquote>
<div>spike times, according to which the spike will be drawn (in ms)</div></blockquote>
<p class="last">duration- The duration of the SpikeTrain (in ms)
channel - Channel argument to enforce a particular channel</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyNCS.group.AddrGroup.spiketrains_single">
<tt class="descname">spiketrains_single</tt><big>(</big><em>spike_time</em>, <em>t_after=100</em><big>)</big><a class="headerlink" href="#pyNCS.group.AddrGroup.spiketrains_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a spiketrain with a single event with the given spike_time for all the addresses in the group.
Inputs:
<em>spike_time</em>: a float or a vector of floats indicating the spike times. If a vector is given, each entry is used once for each address in the logical addresses of the group (in the same order as self.laddr)
<em>t_after</em> ms after the spike</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyNCS.mapping">
<span id="mapping-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">mapping</span></tt> Module<a class="headerlink" href="#module-pyNCS.mapping" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyNCS.mapping.Mapping">
<em class="property">class </em><tt class="descclassname">pyNCS.mapping.</tt><tt class="descname">Mapping</tt><big>(</big><em>name</em>, <em>description=None</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A class representing the mapping between groups of chip addresses.</p>
<dl class="method">
<dt id="pyNCS.mapping.Mapping.add_edge">
<tt class="descname">add_edge</tt><big>(</big><em>groupsrc</em>, <em>groupdst</em>, <em>arrowhead='normal'</em>, <em>dir='forward'</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.add_edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear mapping list.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.connect">
<tt class="descname">connect</tt><big>(</big><em>groupsrc</em>, <em>groupdst</em>, <em>expand=True</em>, <em>fashion='one2one'</em>, <em>fashion_kwargs={}</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap the connect call to all type of different connectivity functions.
Arguments to specific fashion can be passed through keyword arguments.
Default fashion is &#8216;one2one&#8217;. When check is True synapses cannot be
output addresses and somas cannot be input addresses.
Example:</p>
<blockquote>
<div>mymapping.connect(src, dst, &#8220;all2all&#8221;, {&#8216;expand&#8217;:False}</div></blockquote>
<dl class="docutils">
<dt>which is equivalent to:</dt>
<dd>mymapping.__connect_all2all__(src, dst, expand=False}</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.import_from_connections">
<tt class="descname">import_from_connections</tt><big>(</big><em>connections_list</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.import_from_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the list of connections and updates its mapping table.
Connections must be pyNCS.Connection instancies.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.is_connect_possible">
<tt class="descname">is_connect_possible</tt><big>(</big><em>groupsrc</em>, <em>groupdst</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.is_connect_possible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.load">
<tt class="descname">load</tt><big>(</big><em>filename</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the mapping from a file.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.map_events">
<tt class="descname">map_events</tt><big>(</big><em>events</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.map_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Map events in software.
Input:
<em>paddr</em>: a pyST.events object, containing physical addresses
Output:
evetns with mapped Physical addresses</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.mapping_dict">
<tt class="descname">mapping_dict</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.mapping_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of the mappings</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.merge">
<tt class="descname">merge</tt><big>(</big><em>pyncs_mapping</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the existing mapping with a given one. It acts on two
pyNCS.Mapping instancies.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.prepare">
<tt class="descname">prepare</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Run any functions before applying the mapping table</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.save">
<tt class="descname">save</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the mapping into a file.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.save_graph">
<tt class="descname">save_graph</tt><big>(</big><em>filename=None</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.save_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.Mapping.write">
<tt class="descname">write</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.Mapping.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.mapping.PMapping">
<em class="property">class </em><tt class="descclassname">pyNCS.mapping.</tt><tt class="descname">PMapping</tt><big>(</big><em>name</em>, <em>description=None</em><big>)</big><a class="headerlink" href="#pyNCS.mapping.PMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyNCS.mapping.Mapping" title="pyNCS.mapping.Mapping"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.mapping.Mapping</span></tt></a></p>
<p>A class representing the mapping between groups of chip addresses, supporting connection probabilities</p>
<dl class="method">
<dt id="pyNCS.mapping.PMapping.complete">
<tt class="descname">complete</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.mapping.PMapping.complete" title="Permalink to this definition">¶</a></dt>
<dd><p>For all connections without a probability, assume the probability is one</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.mapping.PMapping.max_p">
<tt class="descname">max_p</tt><em class="property"> = 127</em><a class="headerlink" href="#pyNCS.mapping.PMapping.max_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.mapping.PMapping.prepare">
<tt class="descname">prepare</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.mapping.PMapping.prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyNCS.monitors">
<span id="monitors-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">monitors</span></tt> Module<a class="headerlink" href="#module-pyNCS.monitors" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyNCS.monitors.LinearTickLocator">
<em class="property">class </em><tt class="descclassname">pyNCS.monitors.</tt><tt class="descname">LinearTickLocator</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.LinearTickLocator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">matplotlib.ticker.MaxNLocator</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="pyNCS.monitors.MeanRatePlot">
<em class="property">class </em><tt class="descclassname">pyNCS.monitors.</tt><tt class="descname">MeanRatePlot</tt><big>(</big><em>monitors</em>, <em>time_bin=30</em>, <em>mean=True</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.MeanRatePlot" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyNCS.monitors.MonitorPlotBase" title="pyNCS.monitors.MonitorPlotBase"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.monitors.MonitorPlotBase</span></tt></a></p>
<p>A Mean Rate Plot with plots the mean rates of the provided SpikeMonitors.
The figure is automatically plotted</p>
<dl class="method">
<dt id="pyNCS.monitors.MeanRatePlot.draw">
<tt class="descname">draw</tt><big>(</big><em>*args</em>, <em>**plot_args</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.MeanRatePlot.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the mean rate of each SpikeMonitor over time.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.MeanRatePlot.post_process_multifigure">
<tt class="descname">post_process_multifigure</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.MeanRatePlot.post_process_multifigure" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets ylim, labels and ticks</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.monitors.MonitorPlotBase">
<em class="property">class </em><tt class="descclassname">pyNCS.monitors.</tt><tt class="descname">MonitorPlotBase</tt><big>(</big><em>monitors</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.MonitorPlotBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base Class for plotting SpikeMonitors.
Virtual class, use RasterPlot or MeanRatePlot instead.</p>
<dl class="method">
<dt id="pyNCS.monitors.MonitorPlotBase.create_multifigure">
<tt class="descname">create_multifigure</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.MonitorPlotBase.create_multifigure" title="Permalink to this definition">¶</a></dt>
<dd><p>Create base figure</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.MonitorPlotBase.draw">
<tt class="descname">draw</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.MonitorPlotBase.draw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.MonitorPlotBase.iter_remapped">
<tt class="descname">iter_remapped</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.MonitorPlotBase.iter_remapped" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over spikelists in monitors and return a spikelist whose addresses are remapped according to position in monitors. Yields a SpikeMonitor object</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.MonitorPlotBase.iter_remapped_spikelists">
<tt class="descname">iter_remapped_spikelists</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.MonitorPlotBase.iter_remapped_spikelists" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over spikelists in monitors and return a spikelist whose addresses are remapped according to position in monitors. Yields a SpikeMonitorTrain object</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.MonitorPlotBase.iter_spikelists">
<tt class="descname">iter_spikelists</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.MonitorPlotBase.iter_spikelists" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over spikelists in every SpikeMonitor in monitors</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.MonitorPlotBase.post_process_multifigure">
<tt class="descname">post_process_multifigure</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.MonitorPlotBase.post_process_multifigure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.monitors.Monitors">
<em class="property">class </em><tt class="descclassname">pyNCS.monitors.</tt><tt class="descname">Monitors</tt><a class="headerlink" href="#pyNCS.monitors.Monitors" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A container for SpikeMonitors.
This object is automatically generated by NeuroSetup as neurosetup.monitors</p>
<dl class="attribute">
<dt id="pyNCS.monitors.Monitors.channels">
<tt class="descname">channels</tt><a class="headerlink" href="#pyNCS.monitors.Monitors.channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of channels monitored by the current SpikeMonitors</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.Monitors.import_monitors">
<tt class="descname">import_monitors</tt><big>(</big><em>monitors</em>, <em>append=True</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.Monitors.import_monitors" title="Permalink to this definition">¶</a></dt>
<dd><p>Import SpikeMonitors to setup.
monitors: append a SpikeMonitor object or a list of them (replace if append=False)</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.Monitors.import_monitors_otf">
<tt class="descname">import_monitors_otf</tt><big>(</big><em>populations</em>, <em>synapse=None</em>, <em>append=True</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.Monitors.import_monitors_otf" title="Permalink to this definition">¶</a></dt>
<dd><p>Create monitors and Import SpikeMonitors to setup on the fly (otf).
monitors: append a SpikeMonitor object or a list of them
if synapse is None, then the soma is taken as the address group to monitor, otherwise the synapse is taken for all the populations</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.Monitors.iter_remapped_spikelists">
<tt class="descname">iter_remapped_spikelists</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.Monitors.iter_remapped_spikelists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.Monitors.iter_spikelists">
<tt class="descname">iter_spikelists</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.Monitors.iter_spikelists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.Monitors.iterchst">
<tt class="descname">iterchst</tt><big>(</big><em>chstlist</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.Monitors.iterchst" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over channels in monitors and try to find spikelists with matching channels.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.Monitors.normalize_tstart_tstop">
<tt class="descname">normalize_tstart_tstop</tt><big>(</big><em>t_stop=None</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.Monitors.normalize_tstart_tstop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.Monitors.populate_monitors">
<tt class="descname">populate_monitors</tt><big>(</big><em>chstlist</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.Monitors.populate_monitors" title="Permalink to this definition">¶</a></dt>
<dd><p>Populates SpikeMonitors in the list of monitors
chstlist is the dictionary returned by NeuroSetup.stimulate.
(this is also the object that channelAddressing.rawoutput_from_chevents returns (a RawOutput object)</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.Monitors.raster_plot">
<tt class="descname">raster_plot</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.Monitors.raster_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Raster Plotting tool which can handle plotting several SpikeLists/ SpikeMonitors/ monitorSpikeLists</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.monitors.RasterPlot">
<em class="property">class </em><tt class="descclassname">pyNCS.monitors.</tt><tt class="descname">RasterPlot</tt><big>(</big><em>monitors</em>, <em>flat=False</em>, <em>plot_kwargs={}</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.RasterPlot" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyNCS.monitors.MonitorPlotBase" title="pyNCS.monitors.MonitorPlotBase"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.monitors.MonitorPlotBase</span></tt></a></p>
<p>A Raster Plot Class for plotting several Spike Monitors at once.
The figure is automatically plotted, unless it is constructed with plot=False.
plot_kwargs is passed to the final matplotlib plotting function.
kwargs are passed to raster_plot</p>
<dl class="method">
<dt id="pyNCS.monitors.RasterPlot.draw">
<tt class="descname">draw</tt><big>(</big><em>plot_kwargs={}</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.RasterPlot.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws the raster plot.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.RasterPlot.post_process_multifigure">
<tt class="descname">post_process_multifigure</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.RasterPlot.post_process_multifigure" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets ylim, labels and ticks</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.monitors.SpikeMonitor">
<em class="property">class </em><tt class="descclassname">pyNCS.monitors.</tt><tt class="descname">SpikeMonitor</tt><big>(</big><em>addr_group</em>, <em>plot_args=None</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A class for monitoring spiking activity during experimentation.
API is the one of AddrGroup.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pop_mon</span> <span class="o">=</span> <span class="n">SpikeMonitor</span><span class="p">(</span><span class="n">pop</span><span class="o">.</span><span class="n">soma</span><span class="p">,</span> <span class="n">plot_args</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;color&#39;</span><span class="p">:</span><span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="s">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsetup</span><span class="o">.</span><span class="n">monitors</span><span class="o">.</span><span class="n">import_monitors</span><span class="p">([</span><span class="n">pop_mon</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsetup</span><span class="o">.</span><span class="n">stimulate</span><span class="p">(</span><span class="n">stStim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsetup</span><span class="o">.</span><span class="n">monitors</span><span class="o">.</span><span class="n">raster_plot</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.composite_plot">
<tt class="descname">composite_plot</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.composite_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Composite plot of the spikelist. plot_kwargs is passed to the plot in raster_plot, whereas kwargs and args are passed to raster_plot.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the SpikeMonitor</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.firing_rates">
<tt class="descname">firing_rates</tt><big>(</big><em>time_bin=30</em>, <em>mean=True</em>, <em>offset=None</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.firing_rates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.get_normalized_addr">
<tt class="descname">get_normalized_addr</tt><big>(</big><em>s_start=0.0</em>, <em>s_stop=1.0</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.get_normalized_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a an address list with the spikelist addresses mapped linearly to the interval (s_start, s_stop)</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.get_remapped_spikelist">
<tt class="descname">get_remapped_spikelist</tt><big>(</big><em>s_start=0.0</em>, <em>s_stop=1.0</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.get_remapped_spikelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a spikelist whose addresses are mapped linearly to the interval (s_start, s_stop)</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.get_short_name">
<tt class="descname">get_short_name</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.get_short_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get first word of self.name, used for labels in raster plot.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.mean_rate">
<tt class="descname">mean_rate</tt><big>(</big><em>t_start=None</em>, <em>t_stop=None</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.mean_rate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.populate">
<tt class="descname">populate</tt><big>(</big><em>st</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.populate" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate SpikeMonitor with monitered events</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.raster_plot">
<tt class="descname">raster_plot</tt><big>(</big><em>plot_kwargs={}</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.raster_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Raster plot of the spikelist. plot_kwargs is passed to the plot in raster_plot, whereas kwargs and args are passed to raster_plot.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.set_plotargs">
<tt class="descname">set_plotargs</tt><big>(</big><em>kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.set_plotargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes plot arguments according to SpikeMonitor&#8217;s default, but does not overwrite user-defined keyword arguments</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.monitors.SpikeMonitor.sl">
<tt class="descname">sl</tt><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.sl" title="Permalink to this definition">¶</a></dt>
<dd><p>SpikeList of the monitor. The SpikeList is constructed Just in Time.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.monitors.SpikeMonitor.toSpikeListMonitor">
<tt class="descname">toSpikeListMonitor</tt><big>(</big><em>st</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.SpikeMonitor.toSpikeListMonitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform SpikeList <em>st</em> into a monitorSpikeList object</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyNCS.monitors.get_t_start">
<tt class="descclassname">pyNCS.monitors.</tt><tt class="descname">get_t_start</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.get_t_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over all spikelists in Monitors and returns t_start</p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.monitors.get_t_stop">
<tt class="descclassname">pyNCS.monitors.</tt><tt class="descname">get_t_stop</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.get_t_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over all spikelists in Monitors and returns t_stop</p>
</dd></dl>

<dl class="class">
<dt id="pyNCS.monitors.monitorSpikeList">
<em class="property">class </em><tt class="descclassname">pyNCS.monitors.</tt><tt class="descname">monitorSpikeList</tt><big>(</big><em>channel</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.monitorSpikeList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyNCS.pyST.html#pyNCS.pyST.spikes.SpikeList" title="pyNCS.pyST.spikes.SpikeList"><tt class="xref py py-class docutils literal"><span class="pre">pyNCS.pyST.spikes.SpikeList</span></tt></a></p>
<p>A wrapper for the NeuroTools SpikeList</p>
<dl class="method">
<dt id="pyNCS.monitors.monitorSpikeList.id_list_map">
<tt class="descname">id_list_map</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#pyNCS.monitors.monitorSpikeList.id_list_map" title="Permalink to this definition">¶</a></dt>
<dd><p>this function maps the addresses of a spike list into another using the given mapping. Useful for logical to physical translation and vice versa
SL=original spike list
mapping=dictionary containing address mapping</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyNCS.neurosetup">
<span id="neurosetup-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">neurosetup</span></tt> Module<a class="headerlink" href="#module-pyNCS.neurosetup" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyNCS.neurosetup.NeuroSetup">
<em class="property">class </em><tt class="descclassname">pyNCS.neurosetup.</tt><tt class="descname">NeuroSetup</tt><big>(</big><em>setuptype</em>, <em>setupfile</em>, <em>com_kwargs={}</em>, <em>map_kwargs={}</em>, <em>conf_kwargs={}</em>, <em>prefix='./'</em>, <em>offline=False</em>, <em>validate=True</em><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyNCS.neurosetup.NeuroSetup.aerDummy">
<tt class="descname">aerDummy</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup.aerDummy" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a placeholder pyST.addrSpec</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.neurosetup.NeuroSetup.apply">
<tt class="descname">apply</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>sets default monitor/sequencer to this setup</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.neurosetup.NeuroSetup.load">
<tt class="descname">load</tt><big>(</big><em>filename</em>, <em>prefix=''</em>, <em>offline=False</em>, <em>validate=True</em><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup.load" title="Permalink to this definition">¶</a></dt>
<dd><p>parses an XML file created by .dumpXML()</p>
<p>Inputs:
<em>filename</em>: setup file name
<em>prefix</em>: path to be prepended to chipfile names
<em>offline</em>: if True, the chips will not be configured (&#8220;pretend&#8221; mode).</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.neurosetup.NeuroSetup.load_setuptype">
<tt class="descname">load_setuptype</tt><big>(</big><em>filename</em>, <em>prefix=''</em>, <em>validate=True</em><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup.load_setuptype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.neurosetup.NeuroSetup.prepare">
<tt class="descname">prepare</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup.prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.neurosetup.NeuroSetup.reload">
<tt class="descname">reload</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup.reload" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this function if you recovered the object from a pickle and doesnt
have any of the information or the information is corrupted.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.neurosetup.NeuroSetup.run">
<tt class="descname">run</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares mappings, writes it and stimulates.
<em>args</em> and <em>kwargs</em> are keyword arguments passed to Communicator.run()</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.neurosetup.NeuroSetup.stimulate">
<tt class="descname">stimulate</tt><big>(</big><em>stim={}</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup.stimulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-processes, runs communicator, and post-processes.
<em>kwargs</em> are keyword arguments passed to Communicator.run()
Returns a Stas.RawOutput object and populates monitors. The latter is the preferred way of reading data out.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.neurosetup.NeuroSetup.stimulate_raw">
<tt class="descname">stimulate_raw</tt><big>(</big><em>raw_stim</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup.stimulate_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls communicator.run without pre- or post-processing
<em>raw_stim</em>: a numpy array in (addr, time) format. Type should be uint32 (shape = (-1,2)).
Useful for debugging purposes. Format of raw_stim corresponds to the one defined in ComAPI:</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.neurosetup.NeuroSetup.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.NeuroSetup.update" title="Permalink to this definition">¶</a></dt>
<dd><p>updates the default monitor/sequencer (pyST) with the chips contained
in this setup &#8211; always call this function when finished with adding chips</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyNCS.neurosetup.dict_merge">
<tt class="descclassname">pyNCS.neurosetup.</tt><tt class="descname">dict_merge</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.dict_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to merge two dictionaries
returns the merged dictionary</p>
</dd></dl>

<dl class="function">
<dt id="pyNCS.neurosetup.get_addrspec">
<tt class="descclassname">pyNCS.neurosetup.</tt><tt class="descname">get_addrspec</tt><big>(</big><em>node</em>, <em>typ</em><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.get_addrspec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyNCS.neurosetup.parse_and_validate">
<tt class="descclassname">pyNCS.neurosetup.</tt><tt class="descname">parse_and_validate</tt><big>(</big><em>filename</em>, <em>dtd</em>, <em>validate=True</em><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.parse_and_validate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyNCS.neurosetup.xml_parse_parameter">
<tt class="descclassname">pyNCS.neurosetup.</tt><tt class="descname">xml_parse_parameter</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#pyNCS.neurosetup.xml_parse_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to parse parameter leaves of XML</p>
</dd></dl>

</div>
<div class="section" id="module-pyNCS.population">
<span id="population-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">population</span></tt> Module<a class="headerlink" href="#module-pyNCS.population" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyNCS.population.Population">
<em class="property">class </em><tt class="descclassname">pyNCS.population.</tt><tt class="descname">Population</tt><big>(</big><em>name</em>, <em>description</em>, <em>setup=None</em>, <em>chipid=None</em>, <em>neurontype=None</em><big>)</big><a class="headerlink" href="#pyNCS.population.Population" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Population is a set of neurons and corresponding synapses. Population can have parameters
(efficacy of excitatory input synapses, ...).
This is on top of synapses and is intended to be used by the user to create neural networks.</p>
<dl class="method">
<dt id="pyNCS.population.Population.add">
<tt class="descname">add</tt><big>(</big><em>addresses</em><big>)</big><a class="headerlink" href="#pyNCS.population.Population.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a neuron (with all its synapses) to the population. Population has to
be populated already. Address has to be of the appropriate format for
the chip on which the population has been allocated.
Arguments are:</p>
<blockquote>
<div><ul class="simple">
<li>addresses: neuron address in human format (e.g. [10, 2] for neuron
[10,2] in a 2D chip.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.population.Population.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.population.Population.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the population back to its original state.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.population.Population.init">
<tt class="descname">init</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>neurontype</em><big>)</big><a class="headerlink" href="#pyNCS.population.Population.init" title="Permalink to this definition">¶</a></dt>
<dd><p>self.init ==&gt; self.__populate_init__</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.population.Population.isinit">
<tt class="descname">isinit</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.population.Population.isinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if population is initiated with setup, chipid and
neurontype, e.g. not populated.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.population.Population.name">
<tt class="descname">name</tt><a class="headerlink" href="#pyNCS.population.Population.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.population.Population.populate_all">
<tt class="descname">populate_all</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>neurontype</em><big>)</big><a class="headerlink" href="#pyNCS.population.Population.populate_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate all the neurons in the given chip.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.population.Population.populate_by_id">
<tt class="descname">populate_by_id</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>neurontype</em>, <em>id_list</em>, <em>axes=0</em><big>)</big><a class="headerlink" href="#pyNCS.population.Population.populate_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the given addresses (as list) from the neuronblock available
addresses. It takes the first n addresses if offset is not set.
Arguments are:</p>
<blockquote>
<div><ul class="simple">
<li>setup: a NeuroSetup</li>
<li>chipid: id of the chip as expressed in setup.xml</li>
<li>neurontype: id of neurons as expressed in chipfile.xml (e.g.</li>
</ul>
<p>&#8216;excitatory&#8217;)
- id_list: the list of ids for neurons to allocate (human addresses)
- axes: chosse the axes by which to filter the addresses</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.population.Population.populate_by_number">
<tt class="descname">populate_by_number</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>neurontype</em>, <em>n</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#pyNCS.population.Population.populate_by_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the given number of addresses from the neuronblock available
addresses. It takes the first n addresses if offset is not set. Arguments
are:</p>
<blockquote>
<div><ul class="simple">
<li>setup: a NeuroSetup</li>
<li>chipid: id of the chip as expressed in setup.xml</li>
<li>neurontype: id of neurons as expressed in chipfile.xml (e.g.</li>
</ul>
<p>&#8216;excitatory&#8217;)
- n: the number of neuron to allocate
- offset: imposes not to take the first addresses</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.population.Population.populate_by_topology">
<tt class="descname">populate_by_topology</tt><big>(</big><em>setup, chipid, neurontype, topology='rectangle', topology_kwargs={'p2': [63, 0], 'p1': [0, 0]}</em><big>)</big><a class="headerlink" href="#pyNCS.population.Population.populate_by_topology" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the given number of addresses by respecting the chips natural topology (i.e. 0 to n%X+n/Y). It takes the first n addresses if offset is not set. Arguments
are:</p>
<blockquote>
<div><ul class="simple">
<li>setup: a NeuroSetup</li>
<li>neurontype: id of neurons as expressed in chipfile.xml (e.g.</li>
</ul>
<p>&#8216;excitatory&#8217;)
- n: the number of neuron to allocate</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.population.Population.populate_sparse">
<tt class="descname">populate_sparse</tt><big>(</big><em>setup</em>, <em>chipid</em>, <em>neurontype</em>, <em>p=0.3</em><big>)</big><a class="headerlink" href="#pyNCS.population.Population.populate_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate picking random addresses from the neuronblock of all possible
addresses with probability p. Arguments are:</p>
<blockquote>
<div><ul class="simple">
<li>setup: a NeuroSetup</li>
<li>chipid: id of the chip as expressed in setup.xml</li>
<li>neurontype: id of neurons as expressed in chipfile.xml (e.g.</li>
</ul>
<p>&#8216;excitatory&#8217;)
- p: probability of picking neurons in [0, 1)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.population.Population.remove">
<tt class="descname">remove</tt><big>(</big><em>address</em><big>)</big><a class="headerlink" href="#pyNCS.population.Population.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a neuron (with all its synapses) from the population.
Arguments are:</p>
<blockquote>
<div><ul class="simple">
<li>address: neuron address in human format (e.g. [10, 2] for neuron
[10,2] in a 2D chip.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyNCS.population.Population.union">
<tt class="descname">union</tt><big>(</big><em>population</em><big>)</big><a class="headerlink" href="#pyNCS.population.Population.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given population&#8217;s addresses to the existing one. If the
address is already there, it doesn&#8217;t add.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyNCS.AerViewer.html">AerViewer Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.AerViewer.html#id1"><tt class="docutils literal"><span class="pre">AerViewer</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.AerViewer.html#module-pyNCS.AerViewer.Aer1DViewer"><tt class="docutils literal"><span class="pre">Aer1DViewer</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.AerViewer.html#module-pyNCS.AerViewer.Aer2DViewer"><tt class="docutils literal"><span class="pre">Aer2DViewer</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.AerViewer.html#updater1d-module"><tt class="docutils literal"><span class="pre">Updater1D</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.AerViewer.html#updater2d-module"><tt class="docutils literal"><span class="pre">Updater2D</span></tt> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pyNCS.pyST.html">pyST Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.pyST.html#id1"><tt class="docutils literal"><span class="pre">pyST</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.pyST.html#module-pyNCS.pyST.STas"><tt class="docutils literal"><span class="pre">STas</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.pyST.html#module-pyNCS.pyST.STsl"><tt class="docutils literal"><span class="pre">STsl</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.pyST.html#module-pyNCS.pyST.pyST_globals"><tt class="docutils literal"><span class="pre">pyST_globals</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.pyST.html#module-pyNCS.pyST.spikes"><tt class="docutils literal"><span class="pre">spikes</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyNCS.pyST.html#module-pyNCS.pyST.stgen"><tt class="docutils literal"><span class="pre">stgen</span></tt> Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="pyNCS.pyST.html#neurotools-stgen">NeuroTools.stgen</a><ul>
<li class="toctree-l4"><a class="reference internal" href="pyNCS.pyST.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyNCS.pyST.html#functions">Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pyNCS Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">pyNCS</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-pyNCS.ComAPI"><tt class="docutils literal"><span class="pre">ComAPI</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyNCS.ConfAPI"><tt class="docutils literal"><span class="pre">ConfAPI</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyNCS.chip_v2"><tt class="docutils literal"><span class="pre">chip_v2</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyNCS.connection"><tt class="docutils literal"><span class="pre">connection</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyNCS.experimentTools"><tt class="docutils literal"><span class="pre">experimentTools</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyNCS.group"><tt class="docutils literal"><span class="pre">group</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyNCS.mapping"><tt class="docutils literal"><span class="pre">mapping</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyNCS.monitors"><tt class="docutils literal"><span class="pre">monitors</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyNCS.neurosetup"><tt class="docutils literal"><span class="pre">neurosetup</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyNCS.population"><tt class="docutils literal"><span class="pre">population</span></tt> Module</a></li>
<li><a class="reference internal" href="#subpackages">Subpackages</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">pyNCS</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyNCS.AerViewer.html"
                        title="next chapter">AerViewer Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/general/pyNCS.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyNCS.AerViewer.html" title="AerViewer Package"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="pyNCS"
             >previous</a> |</li>
        <li><a href="../index.html">Python NCS tools 0.2 documentation</a> &raquo;</li>
          <li><a href="modules.html" >pyNCS</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, University of Zurich, Emre Neftci, Sadique Sheik, Fabio Stefanini, Giacomo Indiveri.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>