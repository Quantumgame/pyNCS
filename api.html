

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API Documentation &mdash; Python NCS tools 0.2 documentation</title>
    
    <link rel="stylesheet" href="static/default.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="Python NCS tools 0.2 documentation" href="index.html" />
    <link rel="prev" title="The Python Oscilloscope Module" href="pyosc.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyosc.html" title="The Python Oscilloscope Module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Python NCS tools 0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="api-documentation">
<h1>API Documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h1>
<p>This page is autogenerated and contains the docstrings of the python packages used in the <a class="reference external" href="http://ncs.ethz.ch">NCS</a> group</p>
<div class="section" id="module-pyST.STsl">
<span id="stsl"></span><h2>STsl<a class="headerlink" href="#module-pyST.STsl" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyST.STsl.STCompositePlot">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">STCompositePlot</tt><big>(</big><em>SL</em>, <em>id_list=None</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>t_start_rate=None</em>, <em>t_stop_rate=None</em>, <em>display=True</em>, <em>kwargs={}</em>, <em>kwargs_bar={}</em><big>)</big><a class="headerlink" href="#pyST.STsl.STCompositePlot" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a nice Composite plot, <em>i.e.</em> a raster plot combined with a vertical rate plot.</p>
<p>The arguments are identical to STPlotRaster, except for display. 
<em>display</em> If True is given a new figure is created. If [axS,axR] is given, where axS and axR are pylab.axes objects, then the spike rater and the rate plot are plotted there.</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.STPlotRaster">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">STPlotRaster</tt><big>(</big><em>SL</em>, <em>id_list=None</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>display=True</em>, <em>id_color=None</em>, <em>kwargs={}</em><big>)</big><a class="headerlink" href="#pyST.STsl.STPlotRaster" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as spikelist.raster_plot() but with pretty plot options</p>
<p>id_color is used to customize colors according to neuron address (for example inhibitory vs. excitatory)</p>
<p>Example:
&gt;&gt;&gt; id_color = [{&#8216;ids&#8217;:range(124),&#8217;color&#8217;:&#8217;blue&#8217;},{&#8216;ids&#8217;:range(124,128),&#8217;color&#8217;:&#8217;red&#8217;}]
&gt;&gt;&gt; plot_raster(chipout[158],id_color=id_color)</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.composite_plot">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">composite_plot</tt><big>(</big><em>SL</em>, <em>id_list=None</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>t_start_rate=None</em>, <em>t_stop_rate=None</em>, <em>display=True</em>, <em>kwargs={}</em>, <em>kwargs_bar={}</em><big>)</big><a class="headerlink" href="#pyST.STsl.composite_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a nice Composite plot, <em>i.e.</em> a raster plot combined with a vertical rate plot.</p>
<p>The arguments are identical to STPlotRaster, except for display. 
<em>display</em> If True is given a new figure is created. If [axS,axR] is given, where axS and axR are pylab.axes objects, then the spike rater and the rate plot are plotted there.</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.composite_plot_movie">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">composite_plot_movie</tt><big>(</big><em>SL</em>, <em>time_bin=10</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>output='animation.mpg'</em>, <em>bounds=(0</em>, <em>5)</em>, <em>fps=10</em>, <em>display=True</em>, <em>maxrate=None</em>, <em>ratebin=None</em>, <em>kwargs={}</em><big>)</big><a class="headerlink" href="#pyST.STsl.composite_plot_movie" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyST.STsl.composite_plot_superimposed">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">composite_plot_superimposed</tt><big>(</big><em>st_pre, st_post, kwargs={}, colors=['blue', 'k'], id_list=None, t_start=None, t_stop=None, t_start_rate=None, t_stop_rate=None, pre_rate_mult=1.0</em><big>)</big><a class="headerlink" href="#pyST.STsl.composite_plot_superimposed" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a nice Composite plot superimposing two spike trains, a raster plot combined with a vertical rate plot.  
<em>st_pre</em> and <em>st_post</em> are two SpikeLists. st_post will be plotted above st_pre
<em>colors</em> is a list specifying the respective colors for the bars and spikes for st_pre and st_post
<em>kwargs</em> are the keyword arguments for common plot arguments in the raster plots. Default is {&#8216;alpha&#8217;:0.7,&#8217;marker&#8217;:&#8217;,&#8217;} for st_pre and plot_raster defaults for st_post
<em>pre_rate_mult</em> is a float used for plotting the rates of st_pre on a different scale
other arguments are the same as in composite_plot</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.ksi">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">ksi</tt><big>(</big><em>SL</em>, <em>t_stop=800</em>, <em>pow_freq=None</em>, <em>t_bin=10.0</em><big>)</big><a class="headerlink" href="#pyST.STsl.ksi" title="Permalink to this definition">¶</a></dt>
<dd><p>Kuramoto Synchronization Index (KSI) (Kuaramoto 1984) for measuring phase coherency with respect to the strongest    freqeuncy of the population activity.</p>
<p>Returns ksi in the range (0,1). 0 meaning no cohrency and 1 meaning entirely coherent</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd>SL      - SpikeList of duration of at least t_stop
t_stop  - the end of the SpikeTrain (in ms)
t_bin   - time bin for computing population activity and spectrum
pow_freq- if given, this frequency is taken as the strongest frequency</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.mapSpikeListAddresses">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">mapSpikeListAddresses</tt><big>(</big><em>SL</em>, <em>mapping=None</em><big>)</big><a class="headerlink" href="#pyST.STsl.mapSpikeListAddresses" title="Permalink to this definition">¶</a></dt>
<dd><p>this function maps the addresses of a spike list into another using the given mapping. Useful for logical to physical translation and vice versa
SL=original spike list
mapping=dictionary containing address mapping, If mapping is None, then the addresses will be mapped onto a linear scale, i.e. range(len(SL.id_list()))</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STsl.plot_raster">
<tt class="descclassname">pyST.STsl.</tt><tt class="descname">plot_raster</tt><big>(</big><em>SL</em>, <em>id_list=None</em>, <em>t_start=None</em>, <em>t_stop=None</em>, <em>display=True</em>, <em>id_color=None</em>, <em>kwargs={}</em><big>)</big><a class="headerlink" href="#pyST.STsl.plot_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as spikelist.raster_plot() but with pretty plot options</p>
<p>id_color is used to customize colors according to neuron address (for example inhibitory vs. excitatory)</p>
<p>Example:
&gt;&gt;&gt; id_color = [{&#8216;ids&#8217;:range(124),&#8217;color&#8217;:&#8217;blue&#8217;},{&#8216;ids&#8217;:range(124,128),&#8217;color&#8217;:&#8217;red&#8217;}]
&gt;&gt;&gt; plot_raster(chipout[158],id_color=id_color)</p>
</dd></dl>

</div>
<div class="section" id="module-pyST.STas">
<span id="stas"></span><h2>STas<a class="headerlink" href="#module-pyST.STas" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyST.STas.RawOutput">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">RawOutput</tt><big>(</big><em>raw_data</em>, <em>id_data</em>, <em>decoder_dict</em>, <em>t_start=0</em>, <em>t_stop=1000</em>, <em>filter_duplicates=False</em><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>RawOutPut is a class which contains raw AER data per channel (Physical addresses).</p>
<p>It decodes the AER data &#8220;just in time&#8221;</p>
<p>Inputs:
<em>raw_data</em>: events with physical addresses
<em>id_data</em>: all addresses in given channel
<em>decoder_dict</em>: Dictionary of functions for decoding addresses. Key designates the channel
<em>t_start</em>: start time of all spikelists in ms
<em>t_stop</em>: end time of all spikelists in ms
<em>filter_duplicates</em>: If True erases in all channels double events within the a 0.01ms time-frame (buggy hw)</p>
<p>Usage:
#In conjunction with pyAex.netClient</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">netClient</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">&#39;localhost&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_out</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">stimulate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">raw_output</span><span class="p">:</span> <span class="n">sl</span><span class="o">.</span><span class="n">raster_plot</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyST.STas.RawOutput.check_has_key_somewhere">
<tt class="descname">check_has_key_somewhere</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.check_has_key_somewhere" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.RawOutput.decode_all_channels">
<tt class="descname">decode_all_channels</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.decode_all_channels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.RawOutput.decode_data">
<tt class="descname">decode_data</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.decode_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.RawOutput.iterchannels">
<tt class="descname">iterchannels</tt><big>(</big><em>channels</em><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.iterchannels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.RawOutput.iteritems">
<tt class="descname">iteritems</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.iteritems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.RawOutput.print_num_events">
<tt class="descname">print_num_events</tt><big>(</big><em>raw_data</em><big>)</big><a class="headerlink" href="#pyST.STas.RawOutput.print_num_events" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyST.STas.STChannelAddressing">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">STChannelAddressing</tt><a class="headerlink" href="#pyST.STas.STChannelAddressing" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyST.STas.channelAddressing" title="pyST.STas.channelAddressing"><tt class="xref py py-class docutils literal"><span class="pre">channelAddressing</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrBuildHashTable">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrBuildHashTable</tt><big>(</big><em>stas</em><big>)</big><a class="headerlink" href="#pyST.STas.addrBuildHashTable" title="Permalink to this definition">¶</a></dt>
<dd><p>addrBuildHashTable(stas) constructs all possible physical addresses of the given address specification and stores it internally in its hash table (stas.addrExtractFast). This function is typically used for real-time monitoring</p>
<p><em>stas:</em> addrSpec object.</p>
<p><em>Hash tables are not used anymore</em></p>
<p>This function does not scale well.</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrLogicalConstruct">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrLogicalConstruct</tt><big>(</big><em>stas</em>, <em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addrLogicalConstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs Logical addresses, <em>i.e.</em> addresses in float format useful for plotting because they keep the neuron - synapse order.</p>
<p><strong>NOTE:</strong> Logical addresses do not contain channel information</p>
<p><em>addr</em>: address (in a form <a class="reference external" href="pyst.isValidAddress">isValidAddress</a> can understand)</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrLogicalExtract">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrLogicalExtract</tt><big>(</big><em>stas</em>, <em>addrLogical</em><big>)</big><a class="headerlink" href="#pyST.STas.addrLogicalExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Description here</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrLogicalPhysical">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrLogicalPhysical</tt><big>(</big><em>stas</em>, <em>addrLogical</em>, <em>checkLevel=1</em><big>)</big><a class="headerlink" href="#pyST.STas.addrLogicalPhysical" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct translation from Logical Addresses to Physical addresses using a hash table</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrLogicalPhysicalDecode">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrLogicalPhysicalDecode</tt><big>(</big><em>stas</em>, <em>addrLog</em><big>)</big><a class="headerlink" href="#pyST.STas.addrLogicalPhysicalDecode" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes logical addresses and fills the logical to physical hash table</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrPhysicalConstruct">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrPhysicalConstruct</tt><big>(</big><em>stas</em>, <em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addrPhysicalConstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Description here</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrPhysicalExtract">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrPhysicalExtract</tt><big>(</big><em>stas</em>, <em>addrPhys</em><big>)</big><a class="headerlink" href="#pyST.STas.addrPhysicalExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>addrPhysicalExtract takes a physical address as argument and returns a numpy array containing the human readable list of addresses. First dimension is the field type, second dimension is the address.
Uses hash tables for accelerating look-up.</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrPhysicalExtractDecode">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrPhysicalExtractDecode</tt><big>(</big><em>stas</em>, <em>addrPhys</em><big>)</big><a class="headerlink" href="#pyST.STas.addrPhysicalExtractDecode" title="Permalink to this definition">¶</a></dt>
<dd><p>addrPhysicalExtract takes a physical address as argument and returns a list containing the addresses in human readable form.
This is called only the first time the physical address is decoded.</p>
<p><em>stas:</em> addrSpec object.</p>
<p><em>addrPhys</em>: an integer or an iterable containing integers representing physical addresses</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrPhysicalLogical">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrPhysicalLogical</tt><big>(</big><em>stas</em>, <em>addrPhys</em>, <em>checkLevel=1</em><big>)</big><a class="headerlink" href="#pyST.STas.addrPhysicalLogical" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct translation from Physical Addresses to Logical addresses using a hash table</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.addrPhysicalLogicalDecode">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">addrPhysicalLogicalDecode</tt><big>(</big><em>stas</em>, <em>addrPhys</em><big>)</big><a class="headerlink" href="#pyST.STas.addrPhysicalLogicalDecode" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes physical addresses and fills the physical to logical hash table</p>
</dd></dl>

<dl class="class">
<dt id="pyST.STas.addrSpec">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">addrSpec</tt><big>(</big><em>addrStr=''</em>, <em>addrConf=</em><span class="optional">[</span><span class="optional">]</span>, <em>addrPinConf=''</em>, <em>id='NoName'</em><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Address specification class
# NOTE : Documentation is outdated!!</p>
<p><em>addrConf</em>: should be a list of dicts. Each dict should contain the following fields:</p>
<ul class="simple">
<li>&#8216;id&#8217;, whose value is equal to a single, unique, lowercase character.</li>
<li>&#8216;range&#8217;, an iterable containing the possible values the address field can take</li>
<li>&#8216;type&#8217;, which is either 1 (Neuron) or -1 (Synapse).</li>
</ul>
<p><em>addrStr</em>: should contain a list of space-separated pins with a number follwing an uppercase character defining the position on the chip. For example: &#8220;X0 X1 X2 X3 X4 X5 X6 Y4 Y3 Y2 Y1 Y0&#8221;</p>
<p><em>fe</em>: extraction function. this should be a string like &#8216;[X,Y*2]&#8217;, The letters must correspond to those in addrStr
<em>fc</em>: construction function &#8216;[x,y/2]&#8217;, the letters must corrspond to those in addrConf</p>
<p>fe(fc(a)) should be the identity function</p>
<p><em>IMPORTANT:</em> fe and fc are called vectorally (using numpy arrays), so check that the given functions also work with vectors (otherwise numpy.vstack will complain)</p>
<p><em>Example</em>:</p>
<dl class="method">
<dt id="pyST.STas.addrSpec.iter_fields">
<tt class="descname">iter_fields</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec.iter_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.addrSpec.iter_fields_by_pin">
<tt class="descname">iter_fields_by_pin</tt><big>(</big><em>pin_order=None</em><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec.iter_fields_by_pin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.addrSpec.iter_hrf_index">
<tt class="descname">iter_hrf_index</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec.iter_hrf_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over the indexes of addrConf</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.addrSpec.iter_hrfs">
<tt class="descname">iter_hrfs</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec.iter_hrfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over the list addrConf</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.addrSpec.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.addrSpec.update" title="Permalink to this definition">¶</a></dt>
<dd><p>(Re)Generates the object based on the addrStr, addrConf and addrPinConf</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyST.STas.addressEncoder">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">addressEncoder</tt><big>(</big><em>addr_conf</em>, <em>addr_str</em>, <em>addr_pinconf</em><big>)</big><a class="headerlink" href="#pyST.STas.addressEncoder" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyST.STas.addressEncoder.decode">
<tt class="descname">decode</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addressEncoder.decode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.addressEncoder.decode_field">
<tt class="descname">decode_field</tt><big>(</big><em>field</em>, <em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addressEncoder.decode_field" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.addressEncoder.encode">
<tt class="descname">encode</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addressEncoder.encode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.addressEncoder.encode_field">
<tt class="descname">encode_field</tt><big>(</big><em>field</em>, <em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.addressEncoder.encode_field" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyST.STas.channelAddressing">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">channelAddressing</tt><big>(</big><em>stasList, nChannelBits=[15, 16]</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing" title="Permalink to this definition">¶</a></dt>
<dd><p>This class contains the information defining the Channel Addressing Scheme for a multichip setup, i.e. definition of which chips are found on which channel</p>
<p>channelAddressing(stasList,nChannelBits)</p>
<p><em>nChannelBits</em>: Positions of channel bits in the hardware addresses. Default nChannelBits=[15,16]</p>
<p><em>stasList</em>: list of address specification objects, of the same length as len(nChannelBits)**2</p>
<p>See also:
<a class="reference external" href="#pyST.STas.addrSpec">addrSpec</a></p>
<dl class="method">
<dt id="pyST.STas.channelAddressing.addrLogicalConstruct">
<tt class="descname">addrLogicalConstruct</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.addrLogicalConstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs Logical addresses, <em>i.e.</em> addresses in float format useful for plotting because they keep the neuron - synapse order.</p>
<p>Returns a float32 numpy array.</p>
<p><strong>NOTE:</strong> Logical addresses do not contain channel information</p>
<p><em>addr</em>: address (in a form isChannelAddrList() can understand), such as <tt class="docutils literal"><span class="pre">{0:[range(15),2]}</span></tt></p>
<p>See also:</p>
<blockquote>
<div>addrLogicalConstruct, addrLogicalExtract</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.addrLogicalExtract">
<tt class="descname">addrLogicalExtract</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.addrLogicalExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts Logical Address with channel information</p>
<p><em>addr</em>: address (in a form isChannelAddrList() can understand), such as <tt class="docutils literal"><span class="pre">{0:[1.,2.,3.]}</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.addrPhysicalConstruct">
<tt class="descname">addrPhysicalConstruct</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.addrPhysicalConstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs Physical addresses to human readable addresses</p>
<p><em>addr</em>: numpy array of human readable numbers ( the physical addresses )</p>
<p><em>channel</em>: which channel addressing should be appended.</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.addrPhysicalExtract">
<tt class="descname">addrPhysicalExtract</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.addrPhysicalExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts Physical addresses to human readable addresses</p>
<p><em>addr</em>: numpy array of uint32 numbers ( the physical addresses )</p>
<p>Output is channelAddrList, channel where channelEventsList is a list of arrays which contain the addresses and channel is an array of channels.</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.addrPhysicalLogical">
<tt class="descname">addrPhysicalLogical</tt><big>(</big><em>addr</em>, <em>checkLevel=1</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.addrPhysicalLogical" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts Physical addresses to logical addresses (directly)</p>
<p><em>addr</em>: numpy array of uint32 numbers ( the physical addresses )</p>
<p>Output is channelAddrList, channel where channelEventsList is a list of arrays which contain the addresses and channel is an array of channels.</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.buildAllHashTables">
<tt class="descname">buildAllHashTables</tt><big>(</big><em>channels=None</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.buildAllHashTables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.exportAER">
<tt class="descname">exportAER</tt><big>(</big><em>spikeLists</em>, <em>filename=None</em>, <em>format='a'</em>, <em>isi=True</em>, <em>sep='t'</em>, <em>addr_format='%u'</em>, <em>time_format='%u'</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.exportAER" title="Permalink to this definition">¶</a></dt>
<dd><p>spikeLists can be a spikeList, a list of spikelists of dimension nChannels, a dictionary i.e.{channel: spikeList}. If a SpikeList is given, it will be equivalent to {0: spikeLists}.
format specifies whether timestamps (format=&#8217;t&#8217;) or addresses (format=&#8217;a&#8217;) should be on the first column.
<em>addr_format</em> and <em>time_format</em> format to be used by np.savetxt</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.extract">
<tt class="descname">extract</tt><big>(</big><em>ev</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the channel information from an array of hardware events. Returns a channelEvents object. Use addrPhysicalExtract for decoding the adresses instead.</p>
<p><em>eventsArray</em>: numpy array of hardware events (uint32)</p>
<dl class="docutils">
<dt>See also:</dt>
<dd>addrPhysicalExtract</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.generateST">
<tt class="descname">generateST</tt><big>(</big><em>ch_events</em>, <em>normalize=True</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.generateST" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts events from eventsChannel, using the address specification specified for the given channels, returns a list of SpikeList</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.getValue">
<tt class="descname">getValue</tt><big>(</big><em>channel</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the channel mask</p>
<p>channel: int between 0 and len(nChannelBits)**2</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.importAER">
<tt class="descname">importAER</tt><big>(</big><em>input=None</em>, <em>sep='t'</em>, <em>dt=1e-06</em>, <em>format='a'</em>, <em>isi=False</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.importAER" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal function for extracting, translating events from a numpy array. Output is a channelEvents dict</p>
<p><em>input</em>: if a string, will be treated as a filenam, if a numpy array, will be considered as events of dimension 2 x Nevents . By default addresses are on [:,0]</p>
<p><em>format</em>: either &#8216;t&#8217; or &#8216;a&#8217; respectively meaning timestamps and addresses on the first column. (&#8216;a&#8217; by default)</p>
<p><em>kwargs</em> are passed to np.loadtxt</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.isChannelAddrList">
<tt class="descname">isChannelAddrList</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.isChannelAddrList" title="Permalink to this definition">¶</a></dt>
<dd><p>Mostly internal function</p>
<p>Check whether addr is a valid channelAddr list/dict</p>
<p><em>addr</em>: Either list of dimension channelAddressing.nChannels, containing arrays of addresses. The list index is the channel number, or dict whose keys are the channel numbers.</p>
<p>See also:</p>
<blockquote>
<div>Stas.isValidAddress</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.normalizeAER">
<tt class="descname">normalizeAER</tt><big>(</big><em>ch_events</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.normalizeAER" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before extract to throw away pre-stimulus data</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelAddressing.rawoutput_from_chevents">
<tt class="descname">rawoutput_from_chevents</tt><big>(</big><em>ch_events</em>, <em>func=None</em>, <em>normalize=True</em>, <em>filter_duplicates=False</em><big>)</big><a class="headerlink" href="#pyST.STas.channelAddressing.rawoutput_from_chevents" title="Permalink to this definition">¶</a></dt>
<dd><p>this function acts like generateST, but constructs a RawOutput object which delays the decoding until it is necessary.
<em>ch_events</em> is a channelEvents object of type &#8216;p&#8217; (Physical)</p>
<dl class="docutils">
<dt>Inputs:</dt>
<dd><em>func</em> - a dictionary of functions with channels as keys to decode the addresses. If omitted, all the channels are considered</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyST.STas.channelEvents">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">channelEvents</tt><big>(</big><em>channel_events=None</em>, <em>atype='Physical'</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyST.STas.channelEvents.add_adtmch">
<tt class="descname">add_adtmch</tt><big>(</big><em>channel</em>, <em>ad</em>, <em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.add_adtmch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.add_ch">
<tt class="descname">add_ch</tt><big>(</big><em>channel</em>, <em>ev</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.add_ch" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an events object to a channel
Remark: Creates a reference to the provided events! In place changes also affect the events!</p>
</dd></dl>

<dl class="attribute">
<dt id="pyST.STas.channelEvents.atype">
<tt class="descname">atype</tt><a class="headerlink" href="#pyST.STas.channelEvents.atype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.filter_all_by_channel_mapping">
<tt class="descname">filter_all_by_channel_mapping</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.filter_all_by_channel_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies, in-place, the encapsulated events acccording to the one-to-many mapping (key is int/float, value is iterable)
In this function, a different mapping is used for each channel (useful for address that do not contain channel information, for example)</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.filter_all_by_mapping">
<tt class="descname">filter_all_by_mapping</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.filter_all_by_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies, in-place, the encapsulated events acccording to the one-to-many mapping (key is int/float, value is iterable)</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.filter_channel">
<tt class="descname">filter_channel</tt><big>(</big><em>channel_list=None</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.filter_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes (in-place) all channels with are not in channel_list.
If channel_list is omitted, the ch_events is left unchanged</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.flatten">
<tt class="descname">flatten</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.flatten" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.get_all_ad">
<tt class="descname">get_all_ad</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.get_all_ad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.get_all_adtmev">
<tt class="descname">get_all_adtmev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.get_all_adtmev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.get_all_tm">
<tt class="descname">get_all_tm</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.get_all_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.get_all_tmadev">
<tt class="descname">get_all_tmadev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.get_all_tmadev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.get_nev">
<tt class="descname">get_nev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.get_nev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.channelEvents.iter_by_timeslice">
<tt class="descname">iter_by_timeslice</tt><big>(</big><em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.channelEvents.iter_by_timeslice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyST.STas.events">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">events</tt><big>(</big><em>ev=None</em>, <em>atype='p'</em>, <em>isISI=False</em><big>)</big><a class="headerlink" href="#pyST.STas.events" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pyST.STas.events.NF">
<tt class="descname">NF</tt><em class="property"> = 2</em><a class="headerlink" href="#pyST.STas.events.NF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.ad">
<tt class="descname">ad</tt><a class="headerlink" href="#pyST.STas.events.ad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.add_adtm">
<tt class="descname">add_adtm</tt><big>(</big><em>ad</em>, <em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.events.add_adtm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.add_adtmev">
<tt class="descname">add_adtmev</tt><big>(</big><em>ev</em><big>)</big><a class="headerlink" href="#pyST.STas.events.add_adtmev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.atype">
<tt class="descname">atype</tt><a class="headerlink" href="#pyST.STas.events.atype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.data">
<tt class="descname">data</tt><a class="headerlink" href="#pyST.STas.events.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.demultiplex">
<tt class="descname">demultiplex</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.demultiplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a dictionary with addesses as keys and a list of timestamps as values. 
Used internally for generating SpikeLists</p>
</dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#pyST.STas.events.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.empty">
<tt class="descname">empty</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.filter_by_mapping">
<tt class="descname">filter_by_mapping</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#pyST.STas.events.filter_by_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the events, given a mapping dictionary like:
map[src]=[target1,target2,...,targetn],</p>
</dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_ad">
<tt class="descname">get_ad</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_ad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_adISI">
<tt class="descname">get_adISI</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_adISI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_adtm">
<tt class="descname">get_adtm</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_adtm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_adtmev">
<tt class="descname">get_adtmev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_adtmev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_nev">
<tt class="descname">get_nev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_nev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_t_stop">
<tt class="descname">get_t_stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_t_stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_tdur">
<tt class="descname">get_tdur</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_tdur" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_tm">
<tt class="descname">get_tm</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_tmad">
<tt class="descname">get_tmad</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_tmad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.get_tmadev">
<tt class="descname">get_tmadev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.get_tmadev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.iter_by_timeslice">
<tt class="descname">iter_by_timeslice</tt><big>(</big><em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.events.iter_by_timeslice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.nev">
<tt class="descname">nev</tt><a class="headerlink" href="#pyST.STas.events.nev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.normalize_tm">
<tt class="descname">normalize_tm</tt><big>(</big><em>t0=0</em><big>)</big><a class="headerlink" href="#pyST.STas.events.normalize_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.set_abs_tm">
<tt class="descname">set_abs_tm</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.set_abs_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.set_ad">
<tt class="descname">set_ad</tt><big>(</big><em>ad</em><big>)</big><a class="headerlink" href="#pyST.STas.events.set_ad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.set_data">
<tt class="descname">set_data</tt><big>(</big><em>ad</em>, <em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.events.set_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.set_isi">
<tt class="descname">set_isi</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.set_isi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.set_tm">
<tt class="descname">set_tm</tt><big>(</big><em>tm</em><big>)</big><a class="headerlink" href="#pyST.STas.events.set_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyST.STas.events.sort">
<tt class="descname">sort</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.events.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort events by addresses and timestamps (in this order).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.t_stop">
<tt class="descname">t_stop</tt><a class="headerlink" href="#pyST.STas.events.t_stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.tdur">
<tt class="descname">tdur</tt><a class="headerlink" href="#pyST.STas.events.tdur" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyST.STas.events.tm">
<tt class="descname">tm</tt><a class="headerlink" href="#pyST.STas.events.tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyST.STas.extract_id_list">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">extract_id_list</tt><big>(</big><em>addr_conf</em><big>)</big><a class="headerlink" href="#pyST.STas.extract_id_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyST.STas.generateST">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">generateST</tt><big>(</big><em>stas</em>, <em>events</em>, <em>normalize=True</em><big>)</big><a class="headerlink" href="#pyST.STas.generateST" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts events from eventsChannel, using the address specification specified for the given channels, returns a list of SpikeList</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.getDefaultMonChannelAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">getDefaultMonChannelAddress</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.getDefaultMonChannelAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default Monitoring Channel Addressing Scheme (i.e. AER Output). No arguments</p>
<p>See also:
<a class="reference external" href="#pyST.STas.setDefaultMonChannelAddress">setDefaultMonChannelAddress</a></p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.getDefaultSeqChannelAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">getDefaultSeqChannelAddress</tt><big>(</big><big>)</big><a class="headerlink" href="#pyST.STas.getDefaultSeqChannelAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default Monitoring Channel Addressing Scheme (i.e. AER Input). No arguments</p>
<p>See also:
<a class="reference external" href="#pyST.STas.setDefaultSeqChannelAddress">setDefaultSeqChannelAddress</a></p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.isValidAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">isValidAddress</tt><big>(</big><em>stas</em>, <em>addrList</em><big>)</big><a class="headerlink" href="#pyST.STas.isValidAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an internal function which verifies that the given &#8220;human readable&#8221; address is consistent with the address specification. It also takes care of &#8220;filling in&#8221; the addresses: for example [range(15),2] is understood as [range(15),[2]*15].</p>
<p>Raises AssertionError if addrList has incorrect data</p>
<p><em>stas</em>: an address specification object <a class="reference external" href="pyST.addrSpec">addrSpec</a>
<em>addrList</em>: a list of human readable addresses such as [range(15), 5]. It also accepts numpy arrays and transforms it accordingly</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.isValidPhysicalAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">isValidPhysicalAddress</tt><big>(</big><em>stas</em>, <em>addrPhys</em><big>)</big><a class="headerlink" href="#pyST.STas.isValidPhysicalAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the given list, int, numpy array is a valid physical address and outputs a numpy array</p>
</dd></dl>

<dl class="class">
<dt id="pyST.STas.layoutFieldEncoder">
<em class="property">class </em><tt class="descclassname">pyST.STas.</tt><tt class="descname">layoutFieldEncoder</tt><big>(</big><em>aspec</em>, <em>nWidth</em>, <em>position=0</em>, <em>pin=''</em><big>)</big><a class="headerlink" href="#pyST.STas.layoutFieldEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal struct used for addrSpec, performing the pin layout permutation (the information contained in addrSr)</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.load_stas_from_csv">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">load_stas_from_csv</tt><big>(</big><em>CSVfile</em><big>)</big><a class="headerlink" href="#pyST.STas.load_stas_from_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a reduced version of pyNCS.Chip._readCSV, which reads only the addressing information
Inputs:
<em>CSVfile</em> - A csv file describing the chip (a &#8220;chipfile&#8221;).</p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.setDefaultMonChannelAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">setDefaultMonChannelAddress</tt><big>(</big><em>cs</em><big>)</big><a class="headerlink" href="#pyST.STas.setDefaultMonChannelAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default Monitoring Channel Addressing scheme (i.e. AER Output) in pyST globals, and used by pyAex. The argument is then returned when getDefaultMonChannelAddress is called</p>
<p>cs: The Channel Addressing Scheme, instance of the channelAddressing class</p>
<p>See also:
<a class="reference external" href="#pyST.STas.getDefaultMonChannelAddress">getDefaultMonChannelAddress</a></p>
</dd></dl>

<dl class="function">
<dt id="pyST.STas.setDefaultSeqChannelAddress">
<tt class="descclassname">pyST.STas.</tt><tt class="descname">setDefaultSeqChannelAddress</tt><big>(</big><em>cs</em><big>)</big><a class="headerlink" href="#pyST.STas.setDefaultSeqChannelAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default Sequencer Channel Addressing scheme (i.e. AER Input) in pyST globals, and used by pyAex. The argument is then returned when getDefaultMonChannelAddress is called</p>
<p>cs: The Channel Addressing Scheme, instance of the channelAddressing class</p>
<p>See also:
<a class="reference external" href="#pyST.STas.getDefaultSeqChannelAddress">pyST.getDefaultSeqChannelAddress</a></p>
</dd></dl>

</div>
<div class="section" id="module-pyAex">
<span id="pyaex"></span><h2>pyAex<a class="headerlink" href="#module-pyAex" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyAexServer">
<span id="pyaexserver"></span><h2>pyAexServer<a class="headerlink" href="#module-pyAexServer" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyNCS.chip">
<span id="pyncs"></span><h2>pyNCS<a class="headerlink" href="#module-pyNCS.chip" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyNCS.chip.Bias">
<em class="property">class </em><tt class="descclassname">pyNCS.chip.</tt><tt class="descname">Bias</tt><big>(</big><em>r</em>, <em>amdaboard</em>, <em>norm</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Bias" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Class emulating a bias</dt>
<dd><p class="first">-Sadique Sheik, Emre Neftci
April 2009</p>
<p class="last">Bias(chip,properties) where properties is a dict object with the below keys</p>
</dd>
</dl>
<p>[&#8216;<a href="#id2"><span class="problematic" id="id3">*</span></a>channel&#8217;,&#8217;block&#8217;,&#8217;<a href="#id4"><span class="problematic" id="id5">*</span></a>signal&#8217;,&#8217;<a href="#id6"><span class="problematic" id="id7">*</span></a>bias&#8217;,&#8217;range&#8217;,&#8217;description&#8217;,&#8217;fet&#8217;,&#8217;pad&#8217;]</p>
<dl class="method">
<dt id="pyNCS.chip.Bias.disableDAC">
<tt class="descname">disableDAC</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip.Bias.disableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>disableDAC() disables the bias if it is a DAC</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Bias.enableDAC">
<tt class="descname">enableDAC</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip.Bias.enableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>enableDAC() enables the bias if it is a DAC</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Bias.getValue">
<tt class="descname">getValue</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip.Bias.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>getValue() returns bias value</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Bias.setValue">
<tt class="descname">setValue</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Bias.setValue" title="Permalink to this definition">¶</a></dt>
<dd><p>setValue(value) sets the bias value</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Bias.switchoff">
<tt class="descname">switchoff</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip.Bias.switchoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch off the bias</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.chip.Bias.v">
<tt class="descname">v</tt><a class="headerlink" href="#pyNCS.chip.Bias.v" title="Permalink to this definition">¶</a></dt>
<dd><p>Bias value</p>
</dd></dl>

<dl class="attribute">
<dt id="pyNCS.chip.Bias.value">
<tt class="descname">value</tt><a class="headerlink" href="#pyNCS.chip.Bias.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Bias value</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.chip.Biases">
<em class="property">class </em><tt class="descclassname">pyNCS.chip.</tt><tt class="descname">Biases</tt><a class="headerlink" href="#pyNCS.chip.Biases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyNCS.chip.Boards">
<em class="property">class </em><tt class="descclassname">pyNCS.chip.</tt><tt class="descname">Boards</tt><a class="headerlink" href="#pyNCS.chip.Boards" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyNCS.chip.Chip">
<em class="property">class </em><tt class="descclassname">pyNCS.chip.</tt><tt class="descname">Chip</tt><big>(</big><em>CSVfile</em>, <em>id='noname'</em>, <em>amdaid='01'</em>, <em>host='localhost'</em>, <em>amdaClient=None</em>, <em>debug=False</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Class emulating a chip
-Sadique Sheik,Emre Neftci
- April 2009</p>
<p>-extended by <a class="reference external" href="mailto:andstein&#37;&#52;&#48;student&#46;ethz&#46;ch">andstein<span>&#64;</span>student<span>&#46;</span>ethz<span>&#46;</span>ch</a> on February 2010
Chip(CSVfile,id=&#8217;noname&#8217;,amdaid=1)</p>
<p>The CSV file should be in the tab separated csv format</p>
<dl class="method">
<dt id="pyNCS.chip.Chip.disableDAC">
<tt class="descname">disableDAC</tt><big>(</big><em>biasName</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.disableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>disableDAC(&#8216;biasName&#8217;)sets the DAC to tristate</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.enableDAC">
<tt class="descname">enableDAC</tt><big>(</big><em>biasName</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.enableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>enableDAC(&#8216;biasName&#8217;)restores the DAC value in the ram if it was disabled</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.getBias">
<tt class="descname">getBias</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.getBias" title="Permalink to this definition">¶</a></dt>
<dd><p>getBias(biasName) Returns the bias value of &#8220;biasName&#8221;
getBias(biaslist) Returns a dict with biasname and value pairs
getBias(biasName1,biasName2) Returns a dict with biasname and value pairs
getBias() Returns a dict of all {biasName:value,..} pairs</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.getBiasNames">
<tt class="descname">getBiasNames</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.getBiasNames" title="Permalink to this definition">¶</a></dt>
<dd><p>getBiasNames() returns a list of all the biases</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.getChipName">
<tt class="descname">getChipName</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.getChipName" title="Permalink to this definition">¶</a></dt>
<dd><p>return the attribute &#8216;id&#8217; of this Chip object</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.grepbias">
<tt class="descname">grepbias</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.grepbias" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all biases and values containing the given string.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.gui">
<tt class="descname">gui</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.gui" title="Permalink to this definition">¶</a></dt>
<dd><p>gui() pops up the GUI for the chip in a different thread</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.interpret">
<tt class="descname">interpret</tt><big>(</big><em>reply</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.interpret" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal function-Not intended for users. It tries to make sense of the strings returned by the server in the context of the Chip</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.loadBiases">
<tt class="descname">loadBiases</tt><big>(</big><em>CSVfile) loads the bias valuess from the CSV file created with saveBiases(CSVfile</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.loadBiases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.restart">
<tt class="descname">restart</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.restart" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.saveBiases">
<tt class="descname">saveBiases</tt><big>(</big><em>filename</em>, <em>block=None</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.saveBiases" title="Permalink to this definition">¶</a></dt>
<dd><p>saveBiases(fileName) saves all the biases of the chip to a file</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.setBias">
<tt class="descname">setBias</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.setBias" title="Permalink to this definition">¶</a></dt>
<dd><p>setBias(biasName, biasValue) sets the value of &#8220;biasName&#8221; to &#8220;biasValue&#8221;</p>
<dl class="docutils">
<dt>setBias({&#8216;biasName&#8217;:value, ...}) can be used to set more than one bias at a time. Input should be a dict object</dt>
<dd>Optionally you can use debug=True/False for debugging</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.setscannext">
<tt class="descname">setscannext</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.setscannext" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts the scanner position by one</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.setscanx">
<tt class="descname">setscanx</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.setscanx" title="Permalink to this definition">¶</a></dt>
<dd><p>setscanx(x) sets the scanner position to x</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.setscanxy">
<tt class="descname">setscanxy</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.setscanxy" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the scan position on a 2D chip</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chip.Chip.switchoff">
<tt class="descname">switchoff</tt><big>(</big><em>biasName</em><big>)</big><a class="headerlink" href="#pyNCS.chip.Chip.switchoff" title="Permalink to this definition">¶</a></dt>
<dd><p>switchoff(&#8216;biasName&#8217;) switches off the bias</p>
</dd></dl>

</dd></dl>

<div class="section" id="module-pyNCS.chipsetup">
<span id="pyncs-setup"></span><h3>pyNCS.Setup<a class="headerlink" href="#module-pyNCS.chipsetup" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyNCS.chipsetup.Setup">
<em class="property">class </em><tt class="descclassname">pyNCS.chipsetup.</tt><tt class="descname">Setup</tt><big>(</big><em>filename=''</em><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup" title="Permalink to this definition">¶</a></dt>
<dd><p>contains all informations conerning a given multichip aVLSI setup:</p>
<ul class="simple">
<li>a list of <tt class="docutils literal"><span class="pre">pyNCS.Chip</span></tt>, containing each :<ul>
<li>an id identifying this particular instance</li>
<li>its AMDA id</li>
<li>input &amp; output channels</li>
<li>a chipfile containing naming scheme, chip class name etc</li>
</ul>
</li>
<li>for &#8216;setting up a setup&#8217;<ol class="arabic">
<li>initialize</li>
<li>create <a href="#id8"><span class="problematic" id="id9">``</span></a>pyNCS.Chip``s with channel information</li>
<li><tt class="docutils literal"><span class="pre">.add()</span></tt> them</li>
<li><tt class="docutils literal"><span class="pre">.update()</span></tt> the channels</li>
<li><tt class="docutils literal"><span class="pre">.apply()</span></tt> the channels if you want to use this setup as default</li>
</ol>
</li>
<li>capabilities for loading/storing theses informations<ul>
<li><tt class="docutils literal"><span class="pre">load()</span></tt> and <tt class="docutils literal"><span class="pre">save()</span></tt> to save the setting into an <tt class="docutils literal"><span class="pre">.XML</span></tt> file</li>
</ul>
</li>
<li>convinience methods&amp;variables such as<ul>
<li>translate channel,id &lt;-&gt; chip object</li>
<li><tt class="docutils literal"><span class="pre">.seq</span></tt>, <tt class="docutils literal"><span class="pre">.mon</span></tt> : the sequencer/monitor created for this setup</li>
</ul>
</li>
<li>&#8216;dummy&#8217;-chip<ul>
<li>empty channels must be specified nevertheless; that&#8217;s what the dummy
chip is for</li>
<li>you e.g. can use that empty channel for stimulating</li>
</ul>
</li>
</ul>
<dl class="method">
<dt id="pyNCS.chipsetup.Setup.ShowMappingGui">
<tt class="descname">ShowMappingGui</tt><big>(</big><em>update=True</em><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.ShowMappingGui" title="Permalink to this definition">¶</a></dt>
<dd><p>Show MappingGui of the current mapping table.
If update is True it first reads the mapping table from map host.</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chipsetup.Setup.add">
<tt class="descname">add</tt><big>(</big><em>chip</em>, <em>chipid</em><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.add" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a chip-instance to this setup</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chipsetup.Setup.aerDummy">
<tt class="descname">aerDummy</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.aerDummy" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a placeholder pyST.addrSpec</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chipsetup.Setup.apply">
<tt class="descname">apply</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>sets default monitor/sequencer to this setup</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chipsetup.Setup.at">
<tt class="descname">at</tt><big>(</big><em>channel</em>, <em>inout</em><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.at" title="Permalink to this definition">¶</a></dt>
<dd><p>finds a chip by channel</p>
<p>channel : where the chip is connected to</p>
<p>inout : either &#8216;in&#8217; or &#8216;out&#8217; &#8211; from the chip&#8217;s point o view</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chipsetup.Setup.dumpXML">
<tt class="descname">dumpXML</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.dumpXML" title="Permalink to this definition">¶</a></dt>
<dd><p>for backwards compatibility only</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chipsetup.Setup.find">
<tt class="descname">find</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.find" title="Permalink to this definition">¶</a></dt>
<dd><p>finds a chip by id</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chipsetup.Setup.load">
<tt class="descname">load</tt><big>(</big><em>filename</em>, <em>prefix=''</em>, <em>offline=False</em><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.load" title="Permalink to this definition">¶</a></dt>
<dd><p>parses an XML file created by .dumpXML()
<em>filename</em> setup file name
<em>prefix</em> path to be prepended to chipfile names
<em>offline</em> if True, the chips will not be configured (&#8220;pretend&#8221; mode).</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chipsetup.Setup.load_setuptype">
<tt class="descname">load_setuptype</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.load_setuptype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyNCS.chipsetup.Setup.parseXML">
<tt class="descname">parseXML</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.parseXML" title="Permalink to this definition">¶</a></dt>
<dd><p>for backwards compatibility only</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.chipsetup.Setup.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.chipsetup.Setup.update" title="Permalink to this definition">¶</a></dt>
<dd><p>updates the default monitor/sequencer (pyST) with the chips contained
in this setup &#8211; always call this function when finished with adding chips</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-pyNCS.Gui.Gui">
<span id="pyncs-gui"></span><h2>pyNCS.Gui<a class="headerlink" href="#module-pyNCS.Gui.Gui" title="Permalink to this headline">¶</a></h2>
<p>Created on Jul 3, 2009</p>
<p>&#64;author: sadique</p>
<dl class="class">
<dt id="pyNCS.Gui.Gui.CBWindow">
<em class="property">class </em><tt class="descclassname">pyNCS.Gui.Gui.</tt><tt class="descname">CBWindow</tt><a class="headerlink" href="#pyNCS.Gui.Gui.CBWindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Window class for Code Blocks with override functions on delete event</p>
<dl class="method">
<dt id="pyNCS.Gui.Gui.CBWindow.do_delete_event">
<tt class="descname">do_delete_event</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.CBWindow.do_delete_event" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.Gui.Gui.ListnerThread">
<em class="property">class </em><tt class="descclassname">pyNCS.Gui.Gui.</tt><tt class="descname">ListnerThread</tt><big>(</big><em>chip</em>, <em>biasDict</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ListnerThread" title="Permalink to this definition">¶</a></dt>
<dd><p>Thread listening to the server broadcast and Queueing the parsed messages</p>
<dl class="method">
<dt id="pyNCS.Gui.Gui.ListnerThread.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ListnerThread.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive message and queue</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ListnerThread.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ListnerThread.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>To close connection with the server and end the thread</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.Gui.Gui.MyFileChooser">
<em class="property">class </em><tt class="descclassname">pyNCS.Gui.Gui.</tt><tt class="descname">MyFileChooser</tt><a class="headerlink" href="#pyNCS.Gui.Gui.MyFileChooser" title="Permalink to this definition">¶</a></dt>
<dd><p>Class overriding delete event</p>
<dl class="method">
<dt id="pyNCS.Gui.Gui.MyFileChooser.do_delete_event">
<tt class="descname">do_delete_event</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.MyFileChooser.do_delete_event" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.Gui.Gui.ShowWindow">
<em class="property">class </em><tt class="descclassname">pyNCS.Gui.Gui.</tt><tt class="descname">ShowWindow</tt><big>(</big><em>chip</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic gtk based GUI for pyNCS</p>
<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.cbWshow">
<tt class="descname">cbWshow</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.cbWshow" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when the code block button is pressed on the main window</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.destroy">
<tt class="descname">destroy</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when main window is destroyed</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.loadBiases">
<tt class="descname">loadBiases</tt><big>(</big><em>fileChooser</em>, <em>responseId</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.loadBiases" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when Open button is clicked on on loadDialogue</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.loadButton_clicked">
<tt class="descname">loadButton_clicked</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.loadButton_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when load button is clicked on the main window</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.on_refresh">
<tt class="descname">on_refresh</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.on_refresh" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when refresh buton is pressed</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.restartButton_clicked">
<tt class="descname">restartButton_clicked</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.restartButton_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when restart button is pressed on the main window</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.saveBiases">
<tt class="descname">saveBiases</tt><big>(</big><em>fileChooser</em>, <em>responseId</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.saveBiases" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when Open button is clicked on on saveDialogue</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.saveButton_clicked">
<tt class="descname">saveButton_clicked</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.saveButton_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when load button is clicked on the main window</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.saveCBBiases">
<tt class="descname">saveCBBiases</tt><big>(</big><em>fileChooser</em>, <em>responseId</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.saveCBBiases" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when Open button is clicked on saveCBDialog</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.saveCBButton_clicked">
<tt class="descname">saveCBButton_clicked</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.saveCBButton_clicked" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when save button in Circuit block window</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.setBias">
<tt class="descname">setBias</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.setBias" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when setbias button is pressed
Executed when value in the text box is changed/applied</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.sklVChanged">
<tt class="descname">sklVChanged</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.sklVChanged" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when the slider moves</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.switchoffBias">
<tt class="descname">switchoffBias</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.switchoffBias" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when ON/OFF bias button is toggled</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.switchoffBlock">
<tt class="descname">switchoffBlock</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.switchoffBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when code block switchoff button is toggled</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.toggleBias">
<tt class="descname">toggleBias</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.toggleBias" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when disable bias button is toggled</p>
</dd></dl>

<dl class="method">
<dt id="pyNCS.Gui.Gui.ShowWindow.toggleBlock">
<tt class="descname">toggleBlock</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.ShowWindow.toggleBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Executed when code block disable/enable button is toggled</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyNCS.Gui.Gui.UpdateThread">
<em class="property">class </em><tt class="descclassname">pyNCS.Gui.Gui.</tt><tt class="descname">UpdateThread</tt><big>(</big><em>chip</em>, <em>biasDict</em>, <em>updateQueue</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.UpdateThread" title="Permalink to this definition">¶</a></dt>
<dd><p>Thread to act upon the parsed messages received and stored in the updateQueue</p>
<dl class="method">
<dt id="pyNCS.Gui.Gui.UpdateThread.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.UpdateThread.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyNCS.Gui.Gui.showChip">
<tt class="descclassname">pyNCS.Gui.Gui.</tt><tt class="descname">showChip</tt><big>(</big><em>chip</em><big>)</big><a class="headerlink" href="#pyNCS.Gui.Gui.showChip" title="Permalink to this definition">¶</a></dt>
<dd><p>This method runs gtk.gdk.threads_init() before initiating the Gui and then runs gtk.main()</p>
</dd></dl>

</div>
<div class="section" id="module-pyAMDA.AMDA">
<span id="pyamda"></span><h2>pyAMDA<a class="headerlink" href="#module-pyAMDA.AMDA" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyAMDA.AMDA.AmdaBoard">
<em class="property">class </em><tt class="descclassname">pyAMDA.AMDA.</tt><tt class="descname">AmdaBoard</tt><big>(</big><em>board</em>, <em>host='localhost'</em>, <em>amdaClient=None</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard" title="Permalink to this definition">¶</a></dt>
<dd><p>Class emulating an AmdaBoard</p>
<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.cmd">
<tt class="descname">cmd</tt><big>(</big><em>command</em>, <em>wait=False</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>cmdamda(board,command)</p>
<dl class="docutils">
<dt>sends the &#8216;command&#8217; string to the device and returns the output back.</dt>
<dd>the &#8216;board&#8217; can either be the path to the device, or just the device ID.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.commit">
<tt class="descname">commit</tt><big>(</big><em>board</em>, <em>typ</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;board&#8217; can be the amda ID or device path,</p>
<p>&#8216;typ&#8217; is either &#8216;dac&#8217; or &#8216;BG&#8217;</p>
<p>Applies all the values on the ram to the respective channels</p>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.disableDAC">
<tt class="descname">disableDAC</tt><big>(</big><em>channel</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.disableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>disableDAC(board,channel),</p>
<p>&#8216;board&#8217; can be the amda ID or device path,</p>
<p>&#8216;channel&#8217; is the channel number,</p>
<blockquote>
<div>sets the DAC to a tristate mode</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.enableDAC">
<tt class="descname">enableDAC</tt><big>(</big><em>channel</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.enableDAC" title="Permalink to this definition">¶</a></dt>
<dd><p>enableDAC(board,channel),</p>
<p>&#8216;board&#8217; can be the amda ID or device path,</p>
<p>&#8216;channel&#8217; is the channel number,</p>
<blockquote>
<div>reestablishes the DAC&#8217;s old values before it was switched off</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.getchannel">
<tt class="descname">getchannel</tt><big>(</big><em>channel</em>, <em>typ</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.getchannel" title="Permalink to this definition">¶</a></dt>
<dd><p>getchannel(board,channel,typ) ,</p>
<p>&#8216;board&#8217; can be the amda ID or device path,</p>
<p>&#8216;channel&#8217; is the channel number,</p>
<p>&#8216;typ&#8217; is either &#8216;dac&#8217; or &#8216;BG&#8217;</p>
<p>This function returns the values on the channel (from the ram)</p>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.interpret">
<tt class="descname">interpret</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.interpret" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.restart">
<tt class="descname">restart</tt><big>(</big><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>reset(board),</p>
<p>&#8216;board&#8217; can be the amda ID or device path,</p>
<blockquote>
<div>resets the board controller</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.setBiasBuffer">
<tt class="descname">setBiasBuffer</tt><big>(</big><em>board</em>, <em>bufferLength</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.setBiasBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;board&#8217; can be the amda ID or device path,</p>
<blockquote>
<div>&#8216;bb&#8217; is the buffer bits on the bias gen and defaults to FF on the firmware</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.setExtraBits">
<tt class="descname">setExtraBits</tt><big>(</big><em>board</em>, <em>extraBits</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.setExtraBits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;board&#8217; can be the amda ID or device path,</p>
<blockquote>
<div>&#8216;extraBits&#8217; is the number of extra bits and defaults to 4 on the firmware</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyAMDA.AMDA.AmdaBoard.setchannel">
<tt class="descname">setchannel</tt><big>(</big><em>channel</em>, <em>normv</em>, <em>typ</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaBoard.setchannel" title="Permalink to this definition">¶</a></dt>
<dd><p>setchannel(board,channel,normv,typ) ,
&#8216;board&#8217; can be the amda ID or device path, 
&#8216;channel&#8217; is the channel number, 
&#8216;normv&#8217; is the value to be set normalised(0-1) with respect to the vdd. 
&#8216;typ&#8217; is either &#8216;dac&#8217; or &#8216;BG&#8217;</p>
<p>This function sets the values to the ram. You need to commit() in order to get these value to be actually set</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyAMDA.AMDA.AmdaClient">
<em class="property">class </em><tt class="descclassname">pyAMDA.AMDA.</tt><tt class="descname">AmdaClient</tt><big>(</big><em>host</em>, <em>board</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaClient" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyAMDA.AMDA.AmdaClient.cmd">
<tt class="descname">cmd</tt><big>(</big><em>command</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.AmdaClient.cmd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyAMDA.AMDA.AmdaClient.isopen">
<tt class="descname">isopen</tt><a class="headerlink" href="#pyAMDA.AMDA.AmdaClient.isopen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pyAMDA.AMDA.TimeOutException">
<em class="property">exception </em><tt class="descclassname">pyAMDA.AMDA.</tt><tt class="descname">TimeOutException</tt><a class="headerlink" href="#pyAMDA.AMDA.TimeOutException" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception for time out</p>
</dd></dl>

<dl class="function">
<dt id="pyAMDA.AMDA.cmdamda">
<tt class="descclassname">pyAMDA.AMDA.</tt><tt class="descname">cmdamda</tt><big>(</big><em>board</em>, <em>command</em>, <em>wait=False</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.cmdamda" title="Permalink to this definition">¶</a></dt>
<dd><p>cmdamda(board,command)</p>
<dl class="docutils">
<dt>sends the &#8216;command&#8217; string to the device and returns the output back.</dt>
<dd>the &#8216;board&#8217; can either be the path to the device, or just the device ID.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyAMDA.AMDA.result">
<tt class="descclassname">pyAMDA.AMDA.</tt><tt class="descname">result</tt><big>(</big><em>cmdoutput) returns just the actual output(to the right of the '=') from the whole string obtained from the cmdamda(</em><big>)</big><a class="headerlink" href="#pyAMDA.AMDA.result" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyMap">
<span id="pymap"></span><h2>pyMap<a class="headerlink" href="#module-pyMap" title="Permalink to this headline">¶</a></h2>
<p>&#64;author <a class="reference external" href="mailto:andstein&#37;&#52;&#48;student&#46;ethz&#46;ch">andstein<span>&#64;</span>student<span>&#46;</span>ethz<span>&#46;</span>ch</a>
&#64;created january 2010
&#64;version 1.0471975511965976</p>
<p>some classes&amp;modules that should facilitate the mapping process :</p>
<ul class="simple">
<li><a href="#id10"><span class="problematic" id="id11">module-Mapping_</span></a> : a class to construct/load &amp; parse the mapping as it is found on the mapper</li>
<li><a href="#id12"><span class="problematic" id="id13">module-MappingGui_</span></a> : a graphical representation of the Mapping</li>
</ul>
<p><strong>Synopsis</strong> see the source-code of <a href="#id14"><span class="problematic" id="id15">pyMap.show_</span></a> further down</p>
<p><strong>Dependencies</strong></p>
<blockquote>
<div><ul class="simple">
<li>packages <tt class="docutils literal"><span class="pre">pyST</span></tt>, <tt class="docutils literal"><span class="pre">pyNCS</span></tt></li>
<li>you need to setup the default global monitor&amp;sequencer before using this</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="pyMap.rnd">
<tt class="descclassname">pyMap.</tt><tt class="descname">rnd</tt><big>(</big><big>)</big><a class="headerlink" href="#pyMap.rnd" title="Permalink to this definition">¶</a></dt>
<dd><p>random() -&gt; x in the interval [0, 1).</p>
</dd></dl>

<dl class="function">
<dt id="pyMap.show">
<tt class="descclassname">pyMap.</tt><tt class="descname">show</tt><big>(</big><em>setup</em>, <em>type='gauss'</em><big>)</big><a class="headerlink" href="#pyMap.show" title="Permalink to this definition">¶</a></dt>
<dd><p>call this method to visualize some samples mappings</p>
<p><tt class="docutils literal"><span class="pre">setup</span></tt> : a <tt class="docutils literal"><span class="pre">pyNCS.Setup</span></tt> object that specifies the chip-setup</p>
<p><tt class="docutils literal"><span class="pre">type</span></tt> : type of sample setting (e.g. retina-2d, many, gauss, tuturial)</p>
<p>returns a <tt class="docutils literal"><span class="pre">MappingGui</span></tt> object showing the specified mapping</p>
</dd></dl>

<dl class="function">
<dt id="pyMap.test">
<tt class="descclassname">pyMap.</tt><tt class="descname">test</tt><big>(</big><em>setup, client, srcid='dummy', srcaddr=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 0], dstid='dummy', dstaddr=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 1], visualize=False</em><big>)</big><a class="headerlink" href="#pyMap.test" title="Permalink to this definition">¶</a></dt>
<dd><p>checks the mapper, HW&lt;-&gt;SW interaction &#8211; in order to do this, it creates a new mapping
and sends some stimulus to the addresses specified further down (make sure those addresses
are either not in use or silent during the test) and counts the output after the mapper.
it thus ensures that the mapping works and actually maps the way it&#8217;s supposed to. the
mapping is restored after the test. in cause of an <strong>error</strong> an <tt class="docutils literal"><span class="pre">Exception</span></tt> is generated.</p>
<p><tt class="docutils literal"><span class="pre">setup</span></tt> : a pyNCS.Setup object</p>
<p><tt class="docutils literal"><span class="pre">client</span></tt> : pyAex.netMonStimEventsQueue to use for stimulation (None: usd direct STAEXIO)</p>
<p><tt class="docutils literal"><span class="pre">srcid</span></tt>,``dstid``,``srcaddr``,``dstaddr`` : mapping to use for stimulation</p>
<p><tt class="docutils literal"><span class="pre">visualize</span></tt> : set to True if you want rasterplots of input/output</p>
</dd></dl>

<div class="section" id="module-pyMap.Mapping">
<span id="pymap-mapping"></span><h3>pyMap.Mapping<a class="headerlink" href="#module-pyMap.Mapping" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyMap.Mapping.Mapping">
<em class="property">class </em><tt class="descclassname">pyMap.Mapping.</tt><tt class="descname">Mapping</tt><big>(</big><em>setup</em>, <em>logical=False</em>, <em>host='zanzara'</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>a class representing the mapping (see pyAEx)</p>
<p>features:</p>
<blockquote>
<div><ul class="simple">
<li>can initialize itself from an existing mapping</li>
<li>pickable, fast numpy loading/saving</li>
<li>add mapping by chip instead of by channel</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="pyMap.Mapping.Mapping.addByChann">
<tt class="descname">addByChann</tt><big>(</big><em>chann0</em>, <em>a0</em>, <em>chann1</em>, <em>a1</em>, <em>all=False</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.addByChann" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a mapping from one channel to another &#8211; see <tt class="docutils literal"><span class="pre">.addByChip()</span></tt> for explanation of arguments</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.addByChip">
<tt class="descname">addByChip</tt><big>(</big><em>chipid0</em>, <em>a0</em>, <em>chipid1</em>, <em>a1</em>, <em>all=False</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.addByChip" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a mapping from one chip to another &#8211; 1D-ranges may be used</p>
<p>chip : chip-id</p>
<p>a : human readable address (e.g. [x,y,s])</p>
<p>...0 : src</p>
<p>...1 : dst</p>
<p>all : set to true if you want an &#8220;all-to-all&#8221; mapping</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.addrat">
<tt class="descname">addrat</tt><big>(</big><em>a</em>, <em>i</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.addrat" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for addByXXX</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.apply">
<tt class="descname">apply</tt><big>(</big><em>incremential=False</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>applies this mapping on the mapper</p>
<p>if you don&#8217;t want to erase the current mapping, set incremential=True</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.check">
<tt class="descname">check</tt><big>(</big><em>remove=False</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.check" title="Permalink to this definition">¶</a></dt>
<dd><p>filters&amp;redirects any &#8220;forbidden&#8221; synapses</p>
<p>remove : whether to try to redirect or simply remove the forbidden connections</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.chip">
<tt class="descname">chip</tt><big>(</big><em>pa</em>, <em>inout</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.chip" title="Permalink to this definition">¶</a></dt>
<dd><p>returns chip,address for a physical address</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clears all mappings &amp; cache</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.findByChip">
<tt class="descname">findByChip</tt><big>(</big><em>chipid</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.findByChip" title="Permalink to this definition">¶</a></dt>
<dd><p>returns incoming,outgoing containing [chip,addr] each</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.findByChipSrc">
<tt class="descname">findByChipSrc</tt><big>(</big><em>chipid</em>, <em>srca</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.findByChipSrc" title="Permalink to this definition">¶</a></dt>
<dd><p>returns peer (physical) of a given src address (human-readable) on a given chip</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.findByDst">
<tt class="descname">findByDst</tt><big>(</big><em>padst</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.findByDst" title="Permalink to this definition">¶</a></dt>
<dd><p>returns array of mappings that target to padst</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.findByLogicalDst">
<tt class="descname">findByLogicalDst</tt><big>(</big><em>dstchipid</em>, <em>dstla</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.findByLogicalDst" title="Permalink to this definition">¶</a></dt>
<dd><p>finds the mapping where chip,dstla are a target</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.findByLogicalSrc">
<tt class="descname">findByLogicalSrc</tt><big>(</big><em>srcchipid</em>, <em>srcla</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.findByLogicalSrc" title="Permalink to this definition">¶</a></dt>
<dd><p>finds the mapping where chip,srcla are the source</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.findBySrc">
<tt class="descname">findBySrc</tt><big>(</big><em>pasrc</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.findBySrc" title="Permalink to this definition">¶</a></dt>
<dd><p>returns array of mappings that originate from pasrc</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.load">
<tt class="descname">load</tt><big>(</big><em>verbose=False</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.load" title="Permalink to this definition">¶</a></dt>
<dd><p>loads the mapping from the mapper</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.logicalIn">
<tt class="descname">logicalIn</tt><big>(</big><em>pa</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.logicalIn" title="Permalink to this definition">¶</a></dt>
<dd><p>returns chip,logical-address for a physical address on the sequencer</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.logicalOut">
<tt class="descname">logicalOut</tt><big>(</big><em>pa</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.logicalOut" title="Permalink to this definition">¶</a></dt>
<dd><p>returns chip,logical-address for a physical address on the monitor</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.read">
<tt class="descname">read</tt><big>(</big><em>filename</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.read" title="Permalink to this definition">¶</a></dt>
<dd><p>loads the mapping from a file</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.repr">
<tt class="descname">repr</tt><big>(</big><em>pa</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.repr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a string-representation of the given physical address</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.updateAll">
<tt class="descname">updateAll</tt><big>(</big><em>gui=False</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.updateAll" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates a couple of dictionaries for faster translation</p>
<p>only thing that need to be set up is self.mapping</p>
<p>verbose : print out a percentage of mappings processed</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.updateChip">
<tt class="descname">updateChip</tt><big>(</big><em>pa</em>, <em>inout</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.updateChip" title="Permalink to this definition">¶</a></dt>
<dd><p>updates addr_chip_{in|out} caches, returns chip&amp;address</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.updateInOut">
<tt class="descname">updateInOut</tt><big>(</big><em>chip</em>, <em>pa</em>, <em>inout</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.updateInOut" title="Permalink to this definition">¶</a></dt>
<dd><p>updates chips_{in|out} caches</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.updateLogical">
<tt class="descname">updateLogical</tt><big>(</big><em>pa</em>, <em>chip</em>, <em>a</em>, <em>inout</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.updateLogical" title="Permalink to this definition">¶</a></dt>
<dd><p>updates addr_logical_{in|out} caches</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.Mapping.Mapping.write">
<tt class="descname">write</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyMap.Mapping.Mapping.write" title="Permalink to this definition">¶</a></dt>
<dd><p>stores the mapping to a file &#8211; adds &#8216;.npy&#8217; to the filename !</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyMap.MappingGui">
<span id="pymap-mappinggui"></span><h3>pyMap.MappingGui<a class="headerlink" href="#module-pyMap.MappingGui" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyMap.MappingGui.ChipGrid">
<em class="property">class </em><tt class="descclassname">pyMap.MappingGui.</tt><tt class="descname">ChipGrid</tt><big>(</big><em>master</em>, <em>chip</em>, <em>inout</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.ChipGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>a Grid class that represents a Chip object</p>
<p>a neuron is always displayed as a rectangle</p>
<p>the &#8216;active neuron&#8217; is chosen by the position of the mouse pointer</p>
<p>all connections of the &#8216;active&#8217; neuron are displayed on the other chips:</p>
<blockquote>
<div><ul class="simple">
<li>the synapses are identified by color &#8211; se ChipHelper.getColor/ChipHelper.getType</li>
<li>when an input neuron is selected, the colors are shown where the connections come FROM</li>
<li>when an output neuron is selected, the colors are shown at the SYNAPSE&#8217;s place</li>
</ul>
</div></blockquote>
<p>knows how to translate address-lists into coordinates</p>
<p>uses ChipHelper to &#8216;understand&#8217; the design of the chips</p>
<p>use .connect() to establish the logical connection between the chips</p>
<dl class="method">
<dt id="pyMap.MappingGui.ChipGrid.connect">
<tt class="descname">connect</tt><big>(</big><em>a0</em>, <em>peer</em>, <em>a1</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.ChipGrid.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>peer is a ChipGrid, too</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.ChipGrid.coords">
<tt class="descname">coords</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.ChipGrid.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>gets coordinates of an address</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyMap.MappingGui.ChipHelper">
<em class="property">class </em><tt class="descclassname">pyMap.MappingGui.</tt><tt class="descname">ChipHelper</tt><big>(</big><em>chip</em>, <em>inout</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.ChipHelper" title="Permalink to this definition">¶</a></dt>
<dd><p>provides some additional, chip-specific informations about synapse layout etc</p>
<dl class="method">
<dt id="pyMap.MappingGui.ChipHelper.colorAddType">
<tt class="descname">colorAddType</tt><big>(</big><em>widget</em>, <em>col</em>, <em>type</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.ChipHelper.colorAddType" title="Permalink to this definition">¶</a></dt>
<dd><p>integrates a synapse on the color of a neuron</p>
<p>the more excitatory synapses there are, the more the neuron will be green</p>
<p>the more inhibitory synapses there are, the more the neuron will be red</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.ChipHelper.colorZero">
<tt class="descname">colorZero</tt><big>(</big><big>)</big><a class="headerlink" href="#pyMap.MappingGui.ChipHelper.colorZero" title="Permalink to this definition">¶</a></dt>
<dd><p>the color of a neuron without any connections</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.ChipHelper.dims">
<tt class="descname">dims</tt><big>(</big><big>)</big><a class="headerlink" href="#pyMap.MappingGui.ChipHelper.dims" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of dimensions of the neurons on the chip &#8211; not of it&#8217;s addressing scheme</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.ChipHelper.getType">
<tt class="descname">getType</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.ChipHelper.getType" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the type of an address</p>
<p>this can be type of the synapse (inhibitory, ...)</p>
<p>or the type of the output-signal (for the retina)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyMap.MappingGui.Grid">
<em class="property">class </em><tt class="descclassname">pyMap.MappingGui.</tt><tt class="descname">Grid</tt><big>(</big><em>parent</em>, <em>dims=(10</em>, <em>10)</em>, <em>size=(10</em>, <em>10)</em>, <em>followcol='black'</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid" title="Permalink to this definition">¶</a></dt>
<dd><p>this class represents an 2d array of cells</p>
<p>providing a title + a status line</p>
<p>&amp; handlers when mouse clicks/moves over a cell</p>
<p>and implementing a stacked coloring</p>
<dl class="method">
<dt id="pyMap.MappingGui.Grid.appendText">
<tt class="descname">appendText</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.appendText" title="Permalink to this definition">¶</a></dt>
<dd><p>appends text to status line</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.Grid.clearText">
<tt class="descname">clearText</tt><big>(</big><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.clearText" title="Permalink to this definition">¶</a></dt>
<dd><p>clears status-line</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.Grid.mark">
<tt class="descname">mark</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.mark" title="Permalink to this definition">¶</a></dt>
<dd><p>highlights a field by marking a colored rectangle around it</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.Grid.mousecb">
<tt class="descname">mousecb</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.mousecb" title="Permalink to this definition">¶</a></dt>
<dd><p>only called when mouse moves to a new field 
OBS : is called with x,y=-1,-1 when mouse LEAVES, too</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.Grid.paintCell">
<tt class="descname">paintCell</tt><big>(</big><em>x</em>, <em>y</em>, <em>fill=None</em>, <em>outline='#eee'</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.paintCell" title="Permalink to this definition">¶</a></dt>
<dd><p>repaints a grid cell with its last pushed color</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.Grid.pop">
<tt class="descname">pop</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>restores previous color from stack, returns popped color</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.Grid.popup">
<tt class="descname">popup</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.popup" title="Permalink to this definition">¶</a></dt>
<dd><p>shows a Tkinter.Tk window containing text</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.Grid.push">
<tt class="descname">push</tt><big>(</big><em>x</em>, <em>y</em>, <em>col</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.push" title="Permalink to this definition">¶</a></dt>
<dd><p>sets color for grid-field, old color is saved on stack</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.Grid.title">
<tt class="descname">title</tt><big>(</big><em>title</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.title" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the title of the widget</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.Grid.unmark">
<tt class="descname">unmark</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.unmark" title="Permalink to this definition">¶</a></dt>
<dd><p>un-highlights a field</p>
</dd></dl>

<dl class="method">
<dt id="pyMap.MappingGui.Grid.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#pyMap.MappingGui.Grid.update" title="Permalink to this definition">¶</a></dt>
<dd><p>redraws the whole widget</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyMap.MappingGui.MappingGui">
<em class="property">class </em><tt class="descclassname">pyMap.MappingGui.</tt><tt class="descname">MappingGui</tt><big>(</big><em>mapping</em>, <em>verbose=False</em>, <em>debug=False</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.MappingGui" title="Permalink to this definition">¶</a></dt>
<dd><p>a Tkinter.Tk window that holds the chips as ChipGrid objects and interconnects them</p>
<p>the gui does NOT keep track of changes in the mapping</p>
<dl class="method">
<dt id="pyMap.MappingGui.MappingGui.find">
<tt class="descname">find</tt><big>(</big><em>chip</em>, <em>inout</em><big>)</big><a class="headerlink" href="#pyMap.MappingGui.MappingGui.find" title="Permalink to this definition">¶</a></dt>
<dd><p>returns grid that contains chip</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyMap.creator">
<span id="pymap-creator"></span><h3>pyMap.creator<a class="headerlink" href="#module-pyMap.creator" title="Permalink to this headline">¶</a></h3>
<p>methods in this sub-module provide some basic functionality to create complicated
mappings; see the documentation of the different methods for more infos</p>
<dl class="function">
<dt id="pyMap.creator.gaussian2D">
<tt class="descclassname">pyMap.creator.</tt><tt class="descname">gaussian2D</tt><big>(</big><em>mapping</em>, <em>chip0id</em>, <em>a0</em>, <em>chip1id</em>, <em>a1</em>, <em>r=5</em>, <em>gamma=0.7</em><big>)</big><a class="headerlink" href="#pyMap.creator.gaussian2D" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a gaussian-like distribution from one neuron to a group of neurons</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">mapping</span></tt> : a <tt class="docutils literal"><span class="pre">pyMap.Mapping</span></tt> object</li>
<li><tt class="docutils literal"><span class="pre">chip0id</span></tt>, <tt class="docutils literal"><span class="pre">a0</span></tt> : source chip &amp; address of neuron</li>
<li><tt class="docutils literal"><span class="pre">chip1id</span></tt>, <tt class="docutils literal"><span class="pre">a1</span></tt> : destination chip &amp; address of neuron that will be in the center of the mapping</li>
<li><tt class="docutils literal"><span class="pre">r</span></tt> : radius of gauss distribution</li>
<li><tt class="docutils literal"><span class="pre">gamma</span></tt> : .1= quite sharp gauss, .9= quite broad</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="pyMap.creator.rnd">
<tt class="descclassname">pyMap.creator.</tt><tt class="descname">rnd</tt><big>(</big><big>)</big><a class="headerlink" href="#pyMap.creator.rnd" title="Permalink to this definition">¶</a></dt>
<dd><p>random() -&gt; x in the interval [0, 1).</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-pyOsc">
<span id="pyosc"></span><h2>pyOsc<a class="headerlink" href="#module-pyOsc" title="Permalink to this headline">¶</a></h2>
<p>&#64;author <a class="reference external" href="mailto:andstein&#37;&#52;&#48;student&#46;ethz&#46;ch">andstein<span>&#64;</span>student<span>&#46;</span>ethz<span>&#46;</span>ch</a>
&#64;created 20100204
&#64;version 0.1</p>
<p><strong>OVERVIEW</strong></p>
<p>a general wrapper for an oscilloscope. initialize this class with
an actual oscilloscope-&#8216;driver&#8217; as single argument. this object
maintains all internal variables, initializes the actual driver and
wrappes every function call</p>
<p>some features:</p>
<blockquote>
<div><ul class="simple">
<li>configuring the card</li>
<li>triggering</li>
<li>asynchronous data acquisition</li>
<li>config load/save</li>
</ul>
</div></blockquote>
<p>units : <tt class="docutils literal"><span class="pre">milliseconds</span></tt> and <tt class="docutils literal"><span class="pre">millivolts</span></tt> are used unless specified otherwise</p>
<p><strong>Drivers</strong></p>
<p>use one of the provided drivers &#8211; these are contained in the submodules.
there may be important notes on the usage of the individual drivers, make
sure to read them before use...</p>
<dl class="class">
<dt id="pyOsc.Oscilloscope">
<em class="property">class </em><tt class="descclassname">pyOsc.</tt><tt class="descname">Oscilloscope</tt><big>(</big><em>driver</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope" title="Permalink to this definition">¶</a></dt>
<dd><p>a remark about variable/method naming:</p>
<ul class="simple">
<li>it&#8217;s not random</li>
<li>if you want to GET a value, call the corresponding function without
arguments &#8211; e.g. .sr(1024) sets the sample rate to 1khz whilst
.sr() returns the sample rate without changing anything</li>
<li>every method that sets arguments saves them in the dictionary
self.cfg; if a method takes more than one argument, they should
be named and they will be saved in the form of a dictionary</li>
<li>every method in the wrapper has a corresponding method in the
driver (apart from docfg, save, load)</li>
<li>for documentation&#8217;s sake, these methods are all written by hand</li>
</ul>
<dl class="method">
<dt id="pyOsc.Oscilloscope.average">
<tt class="descname">average</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.average" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>input : raw data as returned by .data()</li>
<li>output : raw data in same format but averaged over rounds</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.channels">
<tt class="descname">channels</tt><big>(</big><em>channels=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.channels" title="Permalink to this definition">¶</a></dt>
<dd><p>enables the given channels (list)</p>
<p>please initialize every channel with a range</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.channels_n">
<tt class="descname">channels_n</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.channels_n" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the number of channels of this oscilloscope</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.data">
<tt class="descname">data</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.data" title="Permalink to this definition">¶</a></dt>
<dd><p>get the data from a data acquisition started by start()</p>
<p>returns data in the form { channel:[samples] }</p>
<p>rounds are CONCATENATED</p>
<p>the samples are NOT converted into units</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.docfg">
<tt class="descname">docfg</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.docfg" title="Permalink to this definition">¶</a></dt>
<dd><p>passes the current configuration through the driver</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.done">
<tt class="descname">done</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.done" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if a data acquisition started by start() has finished</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.load">
<tt class="descname">load</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.load" title="Permalink to this definition">¶</a></dt>
<dd><p>loads settings from a file</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.max_samples">
<tt class="descname">max_samples</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.max_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the maximal number of samples in the internal buffer of
the oscilloscope (when using blocking reading)</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.max_sr">
<tt class="descname">max_sr</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.max_sr" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the maximal sample rate supported by this device</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.names">
<tt class="descname">names</tt><big>(</big><em>names=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.names" title="Permalink to this definition">¶</a></dt>
<dd><p>set the channel names to something more meaningful</p>
<p>these will be used in plots etc</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.normalize">
<tt class="descname">normalize</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.normalize" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>input : raw data in the form { chann: [samples...] }</li>
<li>output : normalized data in the form { chann:[ [ms],[mv] ] }</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.plot">
<tt class="descname">plot</tt><big>(</big><em>data</em>, <em>decorate=False</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>plots data using matplotlib</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">data</span></tt> : may be data returned from .data(), .normalize() et al</li>
<li><tt class="docutils literal"><span class="pre">decorate</span></tt> : use only together with &#8216;raw&#8217; data, marks trigger, frame, etc</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.ranges">
<tt class="descname">ranges</tt><big>(</big><em>ranges=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the range of specified channels (in millivolts)</p>
<p>this range is in positive AND negative direction</p>
<p>ranges : a dictionary</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>resets the card to a defined state &#8211; automatically called upon initialization</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.rounds">
<tt class="descname">rounds</tt><big>(</big><em>rounds=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.rounds" title="Permalink to this definition">¶</a></dt>
<dd><p>record an event several times (for averaging etc)</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.sr">
<tt class="descname">sr</tt><big>(</big><em>sr=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.sr" title="Permalink to this definition">¶</a></dt>
<dd><p>set sample acquisition rate [Hz]</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.start">
<tt class="descname">start</tt><big>(</big><em>samples</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.start" title="Permalink to this definition">¶</a></dt>
<dd><p>starts a data acquisition</p>
<p>samples: number of samples per channel per round</p>
<p>see triggers(), setsr(), setrounds(), timeout() for additional options</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.status">
<tt class="descname">status</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.status" title="Permalink to this definition">¶</a></dt>
<dd><p>returns some status information</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stops the card &#8211; e.g. when triggering fails</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.store">
<tt class="descname">store</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.store" title="Permalink to this definition">¶</a></dt>
<dd><p>saves the settings to a file</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.timeout">
<tt class="descname">timeout</tt><big>(</big><em>timeout=None</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>get/set the timeout</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.trigger">
<tt class="descname">trigger</tt><big>(</big><em>chann</em>, <em>mode</em>, <em>limit</em>, <em>offset=0.2</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>convinience wrapper for the more powerful .triggers() method</p>
<p>if you just need a single trigger</p>
</dd></dl>

<dl class="method">
<dt id="pyOsc.Oscilloscope.triggers">
<tt class="descname">triggers</tt><big>(</big><em>triggers=None</em>, <em>offset=0.2</em>, <em>chaining='and'</em><big>)</big><a class="headerlink" href="#pyOsc.Oscilloscope.triggers" title="Permalink to this definition">¶</a></dt>
<dd><p>defines the chain of triggers to be used</p>
<dl class="docutils">
<dt>triggers <span class="classifier-delimiter">:</span> <span class="classifier">a list of dictionaries in the form &#8211; specify an empty list for &#8220;software triggering&#8221;</span></dt>
<dd><ul class="first last">
<li><p class="first">chann : what channel this triggering applies to</p>
</li>
<li><dl class="first docutils">
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd><ul class="first last simple">
<li>on raising edge &#8216;/&#8217;</li>
<li>on falling edge &#8216;&#8217;</li>
<li>in between levels for &gt;xx ms &#8216;Ixx&#8217;</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">limit : level to trigger at in mV (tuple for &#8216;Ixx&#8217;)</p>
</li>
</ul>
</dd>
</dl>
<p>chaining : when the trigger chain is satisfied : &#8216;and&#8217; / &#8216;or&#8217;
offset : at what point in the registered window the trigging event</p>
<blockquote>
<div>will be displayed (.5: 50% pre-triggering data)</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyOsc.test">
<tt class="descclassname">pyOsc.</tt><tt class="descname">test</tt><big>(</big><em>osc</em><big>)</big><a class="headerlink" href="#pyOsc.test" title="Permalink to this definition">¶</a></dt>
<dd><p>call this function if you want to check the setup</p>
<p>it simply plots signals from the first four channels; connect something interesting...</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">osc</span></tt> : the oscilloscope to test - evtl try debug option of driver; channels,trigger etc are NOT modified</li>
<li><tt class="docutils literal"><span class="pre">trigger</span></tt> : tests triggering on Channel 0, raising edge a 0V</li>
</ul>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API Documentation</a><ul>
<li><a class="reference internal" href="#module-pyST.STsl">STsl</a></li>
<li><a class="reference internal" href="#module-pyST.STas">STas</a></li>
<li><a class="reference internal" href="#module-pyAex">pyAex</a></li>
<li><a class="reference internal" href="#module-pyAexServer">pyAexServer</a></li>
<li><a class="reference internal" href="#module-pyNCS.chip">pyNCS</a><ul>
<li><a class="reference internal" href="#module-pyNCS.chipsetup">pyNCS.Setup</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-pyNCS.Gui.Gui">pyNCS.Gui</a></li>
<li><a class="reference internal" href="#module-pyAMDA.AMDA">pyAMDA</a></li>
<li><a class="reference internal" href="#module-pyMap">pyMap</a><ul>
<li><a class="reference internal" href="#module-pyMap.Mapping">pyMap.Mapping</a></li>
<li><a class="reference internal" href="#module-pyMap.MappingGui">pyMap.MappingGui</a></li>
<li><a class="reference internal" href="#module-pyMap.creator">pyMap.creator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-pyOsc">pyOsc</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pyosc.html"
                        title="previous chapter">The Python Oscilloscope Module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="sources/api.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyosc.html" title="The Python Oscilloscope Module"
             >previous</a> |</li>
        <li><a href="index.html">Python NCS tools 0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009, Emre Neftci, Sadique Sheik, Daniel Sonnleithner, Giacomo Indiveri.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>