
The Python Mapper Module
========================

written on 2/12 2010 by `Andreas Steiner <mailto://andstein@student.ethz.ch>`_



Introduction
------------

After reading the `pyST manual <pyst.txt>`_, especially the address translation part, it might seem quite
adventurous setting up a simple mapping and it's easy to see that it will be an enormous task debugging
a complicated mapping in an environment of a changing setup (with different chips all having different
Aex boards with different channel configurations being added/removed to the setup).

That's why this package was created. It does not really add any functionality to the 
`pyST.STas module <api.html#module-pyST.STas>`_, but it offers a much easier way to create complicated
mappings, save them to disk, visualize the result of the mapping and so on.

You might also want to read the `pyMap API documentation <api.html#module-pyMap>`_




Features
--------

- persistent storage via ``read()``, ``write()``
- you can see what is on the mapper without changing it : ``load()``
- when adding a new mapping, an important abstraction is provided via ``addByChip()``
- channel informations etc are all managed by the ``pyNCS.Setup`` class
- more complicated mappings may be created with the helper methods in `pyMap.creator <api.html#module-pyMap.creator>`_
- helpful visualization of mappings via `pyMap.MappingGui <api.html#module-pyMap.MappingGui>`_ : just call ``gui()`` on a mapping object
- the mapping can be ``check()``-ed and eventual forbidden 



Tutorial
--------


Initialization
~~~~~~~~~~~~~~

So let's get started right away. For this tutorial you don't actually need a mapper or a working setup. In theory it should work
on any computer having the software installed. Right now it's still an issue when you load the setup, because the ``pyNCS.Chip``
class tries to connect to the AMDA server, but this should be fixed later on.

First, of course, we need a properly initialized ``pyNCS.Setup`` that contains the information, which channel is used for what
chip for input/output. It also contains the ID of the chips (that will in future be used whenever we refer to a given instance
of a chip) and what ``addressConfiguration`` should be used when converting between human-readable and physical addresses
(that is specified in the different ``chipfiles``) -- you can download the setup file used in this tutorial under
`configuration file <http://ncs.ethz.ch/ncs/internal/manuals-and-how-tos/experiments-with-ncs-vlsi-chips/zenzero.xml>`_

So let's do a

.. code-block:: python

	# load setup for zenzero from local dir
	import pyNCS
	setup= pyNCS.Setup()
	setup.load( 'zenzero.xml' )
	setup.apply()

We now have a working setup and can continue by creating a new, empty `pyMap.Mapping  <api.html#module-pyMap.Mapping>`_

.. code-block:: python

	import pyMap
	m= pyMap.Mapping(setup)

If you want to see the 'real' mapping that will be saved on the mapper device, you can do a

.. code-block:: python

	>>> m.mapping

in your ipython shell and you will get an empty list.



Creating the Mapping
~~~~~~~~~~~~~~~~~~~~

Ok, now let's assume we aactually want to map something. Let's first map the upper half of the retina onto the
``ifslwta`` chip. Because the upper half of the retina has the dimensions ``(64,32)`` and the 1D-wta chip has
the dimensions ``(128,1)`` we obviously need a mapping in the form ``(1,32) -> (2,1)``. That's done as easy
as


.. code-block:: python

	for x in range(64):
		m.addByChip( 'retina',[x,range(32),0], 'ifslwta',[x*2  ,0], all=True)
		m.addByChip( 'retina',[x,range(32),0], 'ifslwta',[x*2+1,2], all=True)

Some explanations:

- the ``ids`` provided are the ones that are specified in the ``zenzero.xml`` setup-file
- the addresses used are in 'human readable' format. Every address has the form of a list, whereas every element in the list
  specifies another part of the address -- the meaning of every field depends on the given chip; in our case it's
  - retina : X-coordinate, Y-coordinate, increase/decrease in contrast (0/1)
  - ifslwta : coordinate of neuron, number of synapse; in our (useless) example, we every pixel on the retina stimulates an inhibitory synapse (0) next to a excitatory synapse (2)
- these addresses may contain one ``range`` that will be extrapolated and create a range of addresses in that way; but it's not
  possible to specify more than one range at the same time
- the flag ``all`` means that every coordinate in the list should be connected to every coordinate in the other list; if you don't
  specify that flag, the two address-ranges need to have the same size and they will be mapped linearly on each other



Ok, that's a good start. But what about some 2D to 2D mapping? By *coincidence*, there are just enough neurons left on the retina
as there are on the if2dwta chip. So let's connect them :


.. code-block:: python

	for y in range(32):
		m.addByChip( 'retina',[range(64),y+32,0],'if2dwta',[range(64),y,1] )

- since it's a linear mapping, we don't specify the ``all`` flag this time.


And what about the ``cpga`` chip you may ask; you probably won't but I'll tell you anyway: We will create some more connections
from the center of the retina onto the many synapses of the cpga:


.. code-block:: python

	for y in range(16,16+32):
		m.addByChip( 'retina',[range(16,16+32),y,1], 'cpga',[range(32),y-16] )

In case you wondered, how many synapses the ``cpga`` chip has, you could verify this by eaxmining the output of
``setup.find('cpga').aerIn.addrConf``


And now let's do something even cooler: Redirecting the output of the ``cpga`` back to the ``if2dwta`` chip, but not linearly
as we did up to now, but via a binary pseudo-gauss distribution. We won't calculate the exact mapping by hand, but we will rather
use a predefined method in the ``pyMap.creator`` subpackage:


.. code-block:: python

	from pyMap.creator import gaussian2D
	from random import randint
	for x in range(32):
		gaussian2D( m,'cpga',[x], 'if2dwta',[randint(0,64),randint(0,32),randint(0,1)] )

- the creator methods need the ``pyMap.Mapping`` to be passed as an argument
- we just specify the src/dst coordinates and take the standard valus for the radius and the sharpness of
  the distribution (those may be specified via the ``r`` and ``gamma`` parameters)


Visualizing the Mapping
~~~~~~~~~~~~~~~~~~~~~~~

So, what mapping do we exactly have now? Of course you can always have a look at the source-code if you
don't remember exactly what you intended to do. But if there is a bug somewhere, it might be quite
difficult finding it, because the only way to analyze what's *actually going on*, you would have to
deciphter the output of ``m.mapping``. Just type a 

.. code-block:: python

	>>> str(m.mapping)

to have an idea of the usefulness of this approach. Or imagine someone set up a mapping on the mapper,
you want to do some experiments with one chip of the setup and you would like to avoid resetting the
mapper in case it's possible -- it's to say in case the mapping won't use the important parts of the
chip you are going to use during your experiment.

Fortunately we are pretty good at analyzing comlex relations via our visual cortex. A simple

.. code-block:: python

	m.gui(verbose=True)

is enough. We specify the ``verbose`` flag because it's a big setting (``len(m.mapping)==8191``) and
the ``pyMap.MappingGui`` has to calculate some hash-tables that will need some time to be prepared.

.. figure:: images/mapping_all.png
   :align: center
   :width: 1002px
   :alt: the mapping visualized

What do the different boxes and colors *mean*?

- Every *cell* corresponds to *one neuron* on the chip. In consequent, only the 2D chips are displayed
  as a real grid.
- On the *left side* you see all the chip's *outputs*. In our case, we created connections from the
  ``retina`` (to the ``cpga``/``if2dwta``/``ifslwta``) and the ``cpga`` (only to the ``if2dwta``).
- On the *right side* are the chip's *inputs*. As you can see, the ``retina`` cannot be found on
  that side, because it only generates output and cannot take any input.
- The *colors* have a special meaning and that meaning is different for every chip. If you are
  interested in the details of the coloring scheme, I suggest you read the source of the
  `pyMap.ChipHelper <api.html#pyMap.MappingGui.ChipHelper>`_. The following remarks apply in general
  - the more saturated a neuron, the more connections it has.
  - *green* corresponds to excitatory
  - *red* corresponds to inhibitory

Ok, so this already gives you a rough overview over the mapping, but how can one see the *exact* connections of a given neuron?
Just move your mouse-pointer!

.. figure:: images/mapping_2d.png
   :align: center
   :width: 1004px
   :alt: who maps onto the 2D chip?

Explanations

- The neuron in question is chosen by the mouse-pointer and is painted in *black* (you may fix the selction by clicking).
- All the connections are displayed as follows
  - they're 'on the other side' because inputs are always connected to outputs and vice versa
  - they're highlight with a black rectangle around the grid
  - their *color* indicates always the **synapse**, no matter whether you are eaxmining a neuron on the input or on the output side. That is because there are many more synapse-codings than output-codings (so far only 2 of the retina).
- In our example we can easily see that the 2D neuron receives input from 1 neuron in the ``retina`` (excitatory) and 2 neurons on
  the ``cpga`` (excitatory and inhibitory)
- Below the grid are displayed the exact addresses of alle the highlight neurons.


If the mapping somehow looks different on your computer, you can avoid retyping the above by just calling


.. code-block:: python

	import pyMap
	pyMap.show(setup,type='tutorial')



Using the Mapping
~~~~~~~~~~~~~~~~~

If you actually wanted to use that mapping for some experiment, it would be enough to do


.. code-block:: python

	m.apply()

This command clears the current mapping on the table and applies the new mapping. **BEWARE**
if you are actually going to do this with the provided sample mapping you will very probably
encounter a frozen setup due to a `bug on the 2D chip <http://ncs.ethz.ch/ncs/internal/circuits-and-pcbs/if2dwta/bugsnquirks>`_
The module provides an easy way of preventing this kind of errors in your scripts. Simply do a

.. code-block:: python

	m.check()

Re-examine the mapping by ``>>> m.gui()`` to see the differences between the two mappings. Now
you can safely ``apply()`` it.

If you want to *backup* the mapping on the mapper before applying your new mapping, do a

.. code-block:: python

	bak= pyMap.Mapping(setup)
	bak.load()
	bak.write( 'bakup' )

After your experiments you could restore that old mapping by typing

.. code-block:: python

	bak= pyMap.Mapping(setup)
	bak.read( 'bakup.npy',verbose=True )



Feedback
~~~~~~~~

If you found this tutorial useful or if you have any questions or if things did not work out
the way they are supposed to, you can always `send me an email <mailto://andstein@student.ethz.ch>`_


